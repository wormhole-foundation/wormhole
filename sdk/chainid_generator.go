//go:build ignore

// This file generates the ChainID methods for the VAA struct in the SDK.
package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"sort"
	"strconv"
	"strings"
	"text/template"
)

type ChainInfo struct {
	Name   string
	Value  int
	GoName string
}

func main() {
	// Parse the source file to extract ChainID constants
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, "vaa/structs.go", nil, parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}

	// Stores each ChainID declared as a constant in vaa/structs.go
	var chains []ChainInfo

	// Walk the AST to find ChainID constants
	ast.Inspect(node, func(n ast.Node) bool {
		switch x := n.(type) {
		case *ast.GenDecl:
			if x.Tok == token.CONST {
				for _, spec := range x.Specs {
					if vspec, ok := spec.(*ast.ValueSpec); ok {
						// Check if this is a ChainID constant
						if vspec.Type != nil {
							if ident, ok := vspec.Type.(*ast.Ident); ok && ident.Name == "ChainID" {
								for i, name := range vspec.Names {
									if name.Name == "ChainIDUnset" {
										// Skip the unset value
										continue
									}

									var value int
									if len(vspec.Values) > i {
										if basic, ok := vspec.Values[i].(*ast.BasicLit); ok {
											if v, err := strconv.Atoi(basic.Value); err == nil {
												value = v
											}
										}
									}

									// Extract the chain name from the constant name
									chainName := strings.TrimPrefix(name.Name, "ChainID")

									// Convert to lowercase for string representation
									chainNameLower := strings.ToLower(chainName)

									// Separate alt-EVM testnet names with underscores.
									// e.g. `PolygonSepolia` --> `polygon_sepolia`.
									// (Don't match on "sepolia" itself though.)
									if strings.HasSuffix(chainNameLower, "sepolia") && len(chainNameLower) > len("sepolia") {
										chainNameLower = fmt.Sprintf("%s_sepolia", strings.TrimSuffix(chainNameLower, "sepolia"))
									}

									chains = append(chains, ChainInfo{
										Name:   chainNameLower,
										Value:  value,
										GoName: name.Name,
									})
								}
							}
						}
					}
				}
			}
		}
		return true
	})

	// Sort by value for consistent output
	sort.Slice(chains, func(i, j int) bool {
		return chains[i].Value < chains[j].Value
	})

	// Generate the code template.
	// NOTE: This should follow gofumpt formatting in order to pass CI checks.
	tmpl := `// Code generated by go generate; DO NOT EDIT.

package vaa

import (
	"fmt"
	"strings"
)

// String returns the string representation of the ChainID
func (c ChainID) String() string {
	switch c {
	case ChainIDUnset:
		return "unset"
{{- range .Chains }}
	case {{ .GoName }}:
		return "{{ .Name }}"
{{- end }}
	default:
		return fmt.Sprintf("unknown chain ID: %d", c)
	}
}

// ChainIDFromString converts from a chain's full name to its corresponding ChainID.
func ChainIDFromString(s string) (ChainID, error) {
	s = strings.ToLower(s)

	switch s {
{{- range .Chains }}
	case "{{ .Name }}":
		return {{ .GoName }}, nil
{{- end }}
	default:
		return ChainIDUnset, fmt.Errorf("unknown chain ID: %s", s)
	}
}

// GetAllNetworkIDs returns all known ChainIDs
func GetAllNetworkIDs() []ChainID {
	return []ChainID{
{{- range .Chains }}
		{{ .GoName }},
{{- end }}
	}
}
`

	outfile := "vaa/chainid_generated.go"
	t, err := template.New("chainid").Parse(tmpl)
	if err != nil {
		log.Fatal(err)
	}

	output, err := os.Create(outfile)
	if err != nil {
		log.Fatal(err)
	}
	defer output.Close()

	err = t.Execute(output, struct {
		Chains []ChainInfo
	}{
		Chains: chains,
	})
	if err != nil {
		log.Fatal(err)
	}

	fmt.Printf("Generated %s\n", outfile)
}
