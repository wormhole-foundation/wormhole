/* Code generated by github.com/srdtrk/go-codegen, DO NOT EDIT. */
package wormhole_ibc

// The instantiation parameters of the core bridge contract. See [`crate::state::ConfigInfo`] for more details on what these fields mean.
type InstantiateMsg struct {
	FeeDenom            string `json:"fee_denom"`
	GovAddress          Binary `json:"gov_address"`
	GovChain            int    `json:"gov_chain"`
	GuardianSetExpirity int    `json:"guardian_set_expirity"`
	// Guardian set to initialise the contract with.
	InitialGuardianSet GuardianSetInfo `json:"initial_guardian_set"`
	ChainId            int             `json:"chain_id"`
}

type ExecuteMsg struct {
	SubmitVAA   *ExecuteMsg_SubmitVAA   `json:"submit_v_a_a,omitempty"`
	PostMessage *ExecuteMsg_PostMessage `json:"post_message,omitempty"`
	// Submit a signed VAA to update the on-chain state.  If processing any of the VAAs returns an error, the entire transaction is aborted and none of the VAAs are committed.
	SubmitUpdateChannelChain *ExecuteMsg_SubmitUpdateChannelChain `json:"submit_update_channel_chain,omitempty"`
}

type QueryMsg struct {
	GuardianSetInfo *QueryMsg_GuardianSetInfo `json:"guardian_set_info,omitempty"`
	VerifyVAA       *QueryMsg_VerifyVAA       `json:"verify_v_a_a,omitempty"`
	GetState        *QueryMsg_GetState        `json:"get_state,omitempty"`
	QueryAddressHex *QueryMsg_QueryAddressHex `json:"query_address_hex,omitempty"`
}

type ExecuteMsg_PostMessage struct {
	Message Binary `json:"message"`
	Nonce   int    `json:"nonce"`
}

type QueryMsg_GuardianSetInfo struct{}

type GetStateResponse struct {
	Fee Coin `json:"fee"`
}

type GuardianSetInfoResponse struct {
	Addresses        []GuardianAddress `json:"addresses"`
	GuardianSetIndex int               `json:"guardian_set_index"`
}

type ExecuteMsg_SubmitVAA struct {
	Vaa Binary `json:"vaa"`
}

type Coin struct {
	Amount Uint128 `json:"amount"`
	Denom  string  `json:"denom"`
}

/*
A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.
# Examples
Use `from` to create instances of this and `u128` to get the value out:
``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);
let b = Uint128::from(42u64); assert_eq!(b.u128(), 42);
let c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```
*/
type Uint128 string

type GetAddressHexResponse struct {
	Hex string `json:"hex"`
}

type ParsedVAA struct {
	Hash             []int `json:"hash"`
	Nonce            int   `json:"nonce"`
	Payload          []int `json:"payload"`
	Sequence         int   `json:"sequence"`
	ConsistencyLevel int   `json:"consistency_level"`
	EmitterAddress   []int `json:"emitter_address"`
	LenSigners       int   `json:"len_signers"`
	Timestamp        int   `json:"timestamp"`
	Version          int   `json:"version"`
	EmitterChain     int   `json:"emitter_chain"`
	GuardianSetIndex int   `json:"guardian_set_index"`
}

type ExecuteMsg_SubmitUpdateChannelChain struct {
	// VAA to submit.  The VAA should be encoded in the standard wormhole wire format.
	Vaa Binary `json:"vaa"`
}

type QueryMsg_VerifyVAA struct {
	BlockTime int    `json:"block_time"`
	Vaa       Binary `json:"vaa"`
}

/*
Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.
This is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.
*/
type Binary string

type QueryMsg_GetState struct{}

type QueryMsg_QueryAddressHex struct {
	Address string `json:"address"`
}

type GuardianAddress struct {
	Bytes []byte `json:"bytes"`
}

type GuardianSetInfo struct {
	Addresses      []GuardianAddress `json:"addresses"`
	ExpirationTime uint64            `json:"expiration_time"`
}
