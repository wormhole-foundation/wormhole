/* Code generated by github.com/srdtrk/go-codegen, DO NOT EDIT. */
package cw_wormhole

// The instantiation parameters of the core bridge contract. See [`crate::state::ConfigInfo`] for more details on what these fields mean.
type InstantiateMsg struct {
	FeeDenom            string `json:"fee_denom"`
	GovAddress          Binary `json:"gov_address"`
	GovChain            int    `json:"gov_chain"`
	GuardianSetExpirity int    `json:"guardian_set_expirity"`
	// Guardian set to initialise the contract with.
	InitialGuardianSet GuardianSetInfo `json:"initial_guardian_set"`
	ChainId            int             `json:"chain_id"`
}

type ExecuteMsg struct {
	SubmitVaa   *ExecuteMsg_SubmitVAA   `json:"submit_v_a_a,omitempty"`
	PostMessage *ExecuteMsg_PostMessage `json:"post_message,omitempty"`
}

type QueryMsg struct {
	GuardianSetInfo *QueryMsg_GuardianSetInfo `json:"guardian_set_info,omitempty"`
	VerifyVaa       *QueryMsg_VerifyVAA       `json:"verify_v_a_a,omitempty"`
	GetState        *QueryMsg_GetState        `json:"get_state,omitempty"`
	QueryAddressHex *QueryMsg_QueryAddressHex `json:"query_address_hex,omitempty"`
}

type ExecuteMsg_PostMessage struct {
	Message Binary `json:"message"`
	Nonce   int    `json:"nonce"`
}

type GuardianSetInfoResponse struct {
	Addresses        []GuardianAddress `json:"addresses"`
	GuardianSetIndex int               `json:"guardian_set_index"`
}

/*
A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.

# Examples

Use `from` to create instances of this and `u128` to get the value out:

``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);

let b = Uint128::from(42u64); assert_eq!(b.u128(), 42);

let c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```
*/
type Uint128 string

type GetStateResponse struct {
	Fee Coin `json:"fee"`
}

type GuardianAddress struct {
	Bytes Binary `json:"bytes"`
}

type QueryMsg_GetState struct{}

type QueryMsg_QueryAddressHex struct {
	Address string `json:"address"`
}

/*
Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.

This is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.
*/
type Binary string

type ExecuteMsg_SubmitVAA struct {
	Vaa Binary `json:"vaa"`
}

type QueryMsg_VerifyVAA struct {
	BlockTime int    `json:"block_time"`
	Vaa       Binary `json:"vaa"`
}

type ParsedVAA struct {
	ConsistencyLevel int    `json:"consistency_level"`
	EmitterAddress   []int  `json:"emitter_address"`
	Hash             []int  `json:"hash"`
	LenSigners       int    `json:"len_signers"`
	Timestamp        int    `json:"timestamp"`
	Version          int    `json:"version"`
	EmitterChain     int    `json:"emitter_chain"`
	GuardianSetIndex int    `json:"guardian_set_index"`
	Nonce            int    `json:"nonce"`
	Payload          []byte `json:"payload"`
	Sequence         int    `json:"sequence"`
}

type Coin struct {
	Amount Uint128 `json:"amount"`
	Denom  string  `json:"denom"`
}

type GuardianSetInfo struct {
	Addresses      []GuardianAddress `json:"addresses"`
	ExpirationTime int               `json:"expiration_time"`
}

type GetAddressHexResponse struct {
	Hex string `json:"hex"`
}

type QueryMsg_GuardianSetInfo struct{}
