// We are using promtail client version v2.8.2:
// promtail must be added using commit hashes instead of version tags, see https://github.com/grafana/loki/issues/2826
// go get github.com/grafana/loki/clients/pkg/promtail/client@9f809eda70babaf583bdf6bf335a28038f286618

package telemetry

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/blendle/zapdriver"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
	"google.golang.org/api/option"

	gkzap "github.com/go-kit/kit/log/zap"
	"github.com/grafana/dskit/backoff"
	"github.com/grafana/dskit/flagext"
	"github.com/grafana/loki/clients/pkg/promtail/api"
	"github.com/grafana/loki/clients/pkg/promtail/client"
	"github.com/grafana/loki/pkg/logproto"
	lokiflag "github.com/grafana/loki/pkg/util/flagext"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promauto"
	"github.com/prometheus/common/config"
	"github.com/prometheus/common/model"
)

// ExternalLoggerLoki implements ExternalLogger for the Grafana Loki cloud logging.
type ExternalLoggerLoki struct {
	// c is the promtail client.
	c client.Client

	// labels is the set of labels to be added to each log entry, based on the severity (since severity is one of the labels).
	labels map[zapcore.Level]model.LabelSet

	// localLogger is the zap localLogger used to log errors generated by the loki adapter. It does not use telemetry.
	localLogger *zap.Logger

	// localChan is used to buffer log messages so that the app does not block on Loki. The Loki internal channel is unbuffered,
	// so we write things to this channel. If this write would block, we peg a metric and drop the log message (although it still
	// gets logged locally). There is then a go routine picking messages off of this local channel and writing them to the Loki
	// channel in a blocking manner.
	localChan chan api.Entry

	// localCancel is used to cancel the go routine on shutdown or a fatal error.
	localCancel context.CancelFunc
}

var (
	lokiMessagesSent = promauto.NewCounter(
		prometheus.CounterOpts{
			Name: "wormhole_loki_messages_sent",
			Help: "Total number of log messages posted to Loki",
		})

	lokiMessagesDropped = promauto.NewCounter(
		prometheus.CounterOpts{
			Name: "wormhole_loki_messages_dropped",
			Help: "Total number of log messages dropped while posting to Loki",
		})
)

func (logger *ExternalLoggerLoki) log(ts time.Time, message json.RawMessage, level zapcore.Level) {
	lokiLabels := logger.labels[level]

	bytes, err := message.MarshalJSON()
	if err != nil {
		logger.localLogger.Error("Failed to marshal log message", zap.Error(err))
		return
	}
	entry := api.Entry{
		Entry: logproto.Entry{
			Timestamp: ts,
			Line:      string(bytes),
		},

		Labels: lokiLabels,
	}

	select {
	case logger.localChan <- entry:
		lokiMessagesSent.Inc()
	default:
		lokiMessagesDropped.Inc()
	}

	// A fatal error exits, which can cause us to lose messages. Flush everything.
	if level == zapcore.FatalLevel {
		// Signal the go routine to shut down the logger and exit.
		logger.localCancel()
	}
}

func (logger *ExternalLoggerLoki) close() error {
	// Signal the go routine to shut down the logger and exit.
	logger.localCancel()
	return nil
}

// NewLokiCloudLogger creates a new Telemetry logger using Grafana Loki Cloud Logging.
// skipPrivateLogs: if set to `true`, logs with the field zap.Bool("_privateLogEntry", true) will not be logged by telemetry.
func NewLokiCloudLogger(ctx context.Context, logger *zap.Logger, url string, productName string, skipPrivateLogs bool, labels map[string]string, opts ...option.ClientOption) (*Telemetry, error) {
	// The localLogger is used to log errors generated by the loki adapter. It does not use telemetry.
	localLogger := logger.With(zap.String("component", "loki"))

	// The gkLogger is passed into the loki client, which expects a go-kit logger.
	gkLogger := gkzap.NewZapSugarLogger(localLogger, zapcore.ErrorLevel)

	// Loki pegs these metrics: https://github.com/grafana/loki/blob/main/clients/pkg/promtail/client/client.go#L71-L127
	m := client.NewMetrics(prometheus.DefaultRegisterer)

	serverURL := flagext.URLValue{}
	err := serverURL.Set(url)
	if err != nil {
		return nil, fmt.Errorf("failed to parse Loki client url: %v", err)
	}

	cfg := client.Config{
		URL:                    serverURL,
		DropRateLimitedBatches: true,
		Client:                 config.HTTPClientConfig{},
		// TenantID: We are not using the tenantID.

		// Using default values from by promtail:
		// https://github.com/grafana/loki/blob/bad691b5091f1ad2f09dbfb30d5395b8f57a3bcd/docs/sources/clients/promtail/configuration.md
		BatchWait:      1 * time.Minute,
		BatchSize:      1048576,
		BackoffConfig:  backoff.Config{MinBackoff: 500 * time.Millisecond, MaxBackoff: 5 * time.Minute, MaxRetries: 10},
		ExternalLabels: lokiflag.LabelSet{},
		Timeout:        10 * time.Second,
	}

	clientMaxLineSize := 1024
	clientMaxLineSizeTruncate := true

	c, err := client.New(m, cfg, 0, clientMaxLineSize, clientMaxLineSizeTruncate, gkLogger)
	if err != nil {
		return nil, fmt.Errorf("failed to create Loki client: %v", err)
	}

	// Since severity is one of the labels, create a label set for each severity to avoid copying the labels map for each log entry.
	lokiLabels := make(map[zapcore.Level]model.LabelSet)
	for level := zapcore.DebugLevel; level <= zapcore.FatalLevel; level++ {
		levLabels := model.LabelSet{}
		for k, v := range labels {
			levLabels[model.LabelName(k)] = model.LabelValue(v)
		}
		levLabels[model.LabelName("product")] = model.LabelValue(productName)
		levLabels[model.LabelName("severity")] = model.LabelValue(level.CapitalString())
		lokiLabels[level] = levLabels
	}

	// Create a buffered channel so the application does not block in the logger. The size of this
	// channel should be big enough to handle a burst of log messages from the app.
	localChan := make(chan api.Entry, 1000)

	// Create a local context with a cancel function so we can signal our go routine to shutdown when the time comes.
	localContext, localCancel := context.WithCancel(ctx)

	// Kick off a go routine to read from the local buffered channel and write to the Loki unbuffered channel.
	go func(ctx context.Context, c client.Client, localC chan api.Entry) {
		for {
			select {
			case <-ctx.Done():
				c.Stop()
				return
			case entry := <-localC:
				c.Chan() <- entry // can_block: That's why we are in this separate go routine.
			}
		}
	}(localContext, c, localChan)

	return &Telemetry{
		encoder: &guardianTelemetryEncoder{
			Encoder: zapcore.NewJSONEncoder(zapdriver.NewProductionEncoderConfig()),
			logger: &ExternalLoggerLoki{
				c:           c,
				labels:      lokiLabels,
				localLogger: localLogger,
				localChan:   localChan,
				localCancel: localCancel,
			},
			skipPrivateLogs: skipPrivateLogs,
		},
	}, nil
}
