package tss

import (
	"context"
	"errors"
	"sync/atomic"

	"github.com/certusone/wormhole/node/pkg/common"
	"github.com/certusone/wormhole/node/pkg/guardiansigner"
	gossipv1 "github.com/certusone/wormhole/node/pkg/proto/gossip/v1"
	ethcommon "github.com/ethereum/go-ethereum/common"
	"github.com/wormhole-foundation/wormhole/sdk/vaa"
	"github.com/xlabs/multi-party-sig/pkg/math/curve"
	tsscommon "github.com/xlabs/tss-common"
	"github.com/xlabs/tss-common/service/signer"
	"google.golang.org/grpc"
)

type SignerConnection interface {
	// Connect establishes a connection to the signer service.
	// It blocks until the connection is established or an error occurs.
	// Can be used as supervisor.Runnable [ensuring rapid restarts on failure].
	Connect(ctx context.Context) error

	Signer
	Gossiper
}

// The TssGossiper interface represents the ability to listen and publish new TSS related gossip to the network.
// It is specifically used to abstract the interaction of the TSS signer with the P2P layer for VAA gossiping.
type Gossiper interface {
	// tells the gossiper on new TSS message to inspect and learn about. (e.g., new VAA from a leader entity.)
	Inform(*gossipv1.TSSGossipMessage) error // TODO: should receive VAA, and signature of LEADER.

	// Outbound returns a channel that produces TSS gossip messages to be sent to the network.
	// These messages are typically generated by the TSS signer when it needs to share information with other peers.
	Outbound() <-chan *gossipv1.TSSGossipMessage // in essences, currently only a leader will produce messages.
}

/*
The Signer interface represents a TSS signer service that can be used to request signatures.
*/
type Signer interface {
	/*
		AsyncSign starts an asynchronous signing request.
		The produced signature can be received from ProducedSignatures() channel.
		The request must contain the digest to be signed and the protocol to use.

		If a specific committee is needed, it can be specified via rq.CommitteeMembers. (nil means use pseudo-random committee).
		The committee members are specified via their public keys (guardian public keys).
		If the signer is not configured to recognize the specified committee members, it'll return an error.
	*/
	AsyncSign(rq *signer.SignRequest) error
	// Outputs signatures as they are produced. doesn't guarantee order.
	Response() <-chan *signer.SignResponse

	// TODO: Missing signerService API! The SignerService should support both GetPublicData data and verify.
	// GetPublicKey gets the public information of the signer.
	GetPublicData(context.Context) (*signer.PublicData, error)
	// GetPublicKey gets the public key for the specified protocol type.
	GetPublicKey(context.Context, tsscommon.ProtocolType) (curve.Point, error)
	// Verify verifies a signature against the provided public data.
	Verify(context.Context, *signer.VerifySignatureRequest) error

	// Witness new VAA is used by a LEADER to inform all peers of a new VAA observed on the network and to sign it!
	// If this signer is a leader: it'll use the p2p network to tell all peers to sign the
	// the context parameter is due to the usage of guardianSigner which may need it for signing.
	WitnessNewVaaV1(ctx context.Context, v *vaa.VAA) error
}

// Ensure interfaces are implemented.
var (
	_ SignerConnection = (*SignerClient)(nil)
	_ Signer           = (*SignerClient)(nil)
)

// func TODO() SignerConnection { // TODO: remove
// 	return &SignerClient{}
// }

type Parameters struct {
	// Path to the signer service socket (hostname, ip).
	SocketPath string
	// grpc dial options to connect to the signer service (including tls.credentials or insecure connection).
	DialOpts []grpc.DialOption

	LeaderAddress ethcommon.Address
	// index of this guardian in the guardian set. should be same for all guardians in the network.
	Self           ethcommon.Address
	GST            *common.GuardianSetState
	GuardianSigner guardiansigner.GuardianSigner
}

// The opts should provide the dial options to connect to the signer service. this includes tls.credentials.
func NewSigner(p Parameters) (*SignerClient, error) {
	// todo: create a goroutine with a map that will match requests to responses and output them to the out channel.
	// it will also use a logger to log errors, etc.
	// closes once the context is cancelled.

	for _, opt := range p.DialOpts {
		if opt == nil {
			return nil, errors.New("nil grpc dial option provided")
		}
	}

	if p.GST == nil {
		return nil, errors.New("guardian set state must not be nil")
	}
	if p.GuardianSigner == nil {
		return nil, errors.New("guardian signer must not be nil")
	}
	if p.SocketPath == "" {
		return nil, errors.New("socket path must not be empty")
	}

	sc := &SignerClient{
		dialOpts:   p.DialOpts,
		socketPath: p.SocketPath,
		conn: &connChans{
			signRequests:  make(chan *signer.SignRequest, 100),  // TODO: buffer sizes?
			signResponses: make(chan *signer.SignResponse, 100), // TODO: buffer sizes?
			unaryRequests: make(chan unaryRequest, 100),         // TODO: buffer sizes?
		},
		out:       make(chan *tsscommon.SignatureData),
		connected: atomic.Int64{},
		vaaData: vaaHandling{
			isLeader:       p.LeaderAddress == p.Self && p.Self != (ethcommon.Address{}), // only if self is defined.
			leaderAddress:  p.LeaderAddress,
			gst:            p.GST,
			GuardianSigner: p.GuardianSigner,
			gossipOutput:   make(chan *gossipv1.TSSGossipMessage, 100), // TODO: buffer sizes?
			incomingGossip: make(chan *gossipv1.TSSGossipMessage, 100), // TODO: buffer sizes?
		},
	}

	return sc, nil
}
