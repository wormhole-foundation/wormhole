package tss

import (
	"context"
	"errors"
	"sync/atomic"

	gossipv1 "github.com/certusone/wormhole/node/pkg/proto/gossip/v1"
	"github.com/wormhole-foundation/wormhole/sdk/vaa"
	tsscommon "github.com/xlabs/tss-common"
	"github.com/xlabs/tss-common/service/signer"
	"google.golang.org/grpc"
)

type SignerConnection interface {
	// Connect establishes a connection to the signer service.
	// It blocks until the connection is established or an error occurs.
	// Can be used as supervisor.Runnable [ensuring rapid restarts on failure].
	Connect(ctx context.Context) error

	Signer
	Gossiper
}

// The TssGossiper interface represents the ability to listen and publish new TSS related gossip to the network.
// It is specifically used to abstract the interaction of the TSS signer with the P2P layer for VAA gossiping.
type Gossiper interface {
	// tells the gossiper on new TSS message to inspect and learn about. (e.g., new VAA from a leader entity.)
	Inform(*gossipv1.TSSGossipMessage) error // TODO: should receive VAA, and signature of LEADER.

	// Outbound returns a channel that produces TSS gossip messages to be sent to the network.
	// These messages are typically generated by the TSS signer when it needs to share information with other peers.
	Outbound() <-chan *gossipv1.TSSGossipMessage // in essences, currently only a leader will produce messages.
}

/*
The Signer interface represents a TSS signer service that can be used to request signatures.
*/
type Signer interface {
	/*
		AsyncSign starts an asynchronous signing request.
		The produced signature can be received from ProducedSignatures() channel.
		The request must contain the digest to be signed and the protocol to use.

		If a specific committee is needed, it can be specified via rq.CommitteeMembers. (nil means use pseudo-random committee).
		The committee members are specified via their public keys (guardian public keys).
		If the signer is not configured to recognize the specified committee members, it'll return an error.
	*/
	AsyncSign(rq *signer.SignRequest) error
	// Outputs signatures as they are produced. doesn't guarantee order.
	Response() <-chan *signer.SignResponse

	// TODO: Missing signerService API! The SignerService should support both GetPublicData data and verify.
	// GetPublicKey gets the public information of the signer.
	GetPublicData(context.Context) (*signer.PublicData, error)
	// Verify verifies a signature against the provided public data.
	Verify(context.Context, *signer.VerifySignatureRequest) error

	// Witness new VAA is used by a LEADER to inform all peers of a new VAA observed on the network and to sign it!
	// If this signer is a leader: it'll use the p2p network to tell all peers to sign the
	// the context parameter is due to the usage of guardianSigner which may need it for signing.
	WitnessNewVaaV1(ctx context.Context, v *vaa.VAA) error
}

// Ensure interfaces are implemented.
var (
	_ SignerConnection = (*signerClient)(nil)
	_ Signer           = (*signerClient)(nil)
)

func TODO() SignerConnection { // TODO: remove
	return &signerClient{}
}

// The opts should provide the dial options to connect to the signer service. this includes tls.credentials.
func NewSigner(socketPath string, opts ...grpc.DialOption) (*signerClient, error) {
	// todo: create a goroutine with a map that will match requests to responses and output them to the out channel.
	// it will also use a logger to log errors, etc.
	// closes once the context is cancelled.

	for _, opt := range opts {
		if opt == nil {
			return nil, errors.New("nil grpc dial option provided")
		}
	}

	sc := &signerClient{
		dialOpts:   opts,
		socketPath: socketPath,
		conn: &connChans{
			signRequests:  make(chan *signer.SignRequest, 100),  // TODO: buffer sizes?
			signResponses: make(chan *signer.SignResponse, 100), // TODO: buffer sizes?
			unaryRequests: make(chan unaryRequest, 100),         // TODO: buffer sizes?
		},
		out:       make(chan *tsscommon.SignatureData),
		connected: atomic.Int64{},
	}

	return sc, nil
}
