package guardiand

import (
	"bytes"
	"context"
	"crypto/ecdsa"
	"encoding/hex"
	"fmt"
	"math"
	"math/big"
	"strconv"
	"strings"
	"sync"
	"testing"
	"time"

	"github.com/certusone/wormhole/node/pkg/common"
	gossipv1 "github.com/certusone/wormhole/node/pkg/proto/gossip/v1"
	"github.com/wormhole-foundation/wormhole/sdk/vaa"

	ethCommon "github.com/ethereum/go-ethereum/common"
	ethCrypto "github.com/ethereum/go-ethereum/crypto"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"go.uber.org/zap"
	"google.golang.org/protobuf/proto"
)

const (
	testSigner = "beFA429d57cD18b7F8A4d91A2da9AB4AF05d0FBe"

	fatalError = math.MaxInt

	// Speed things up for testing purposes.
	requestTimeoutForTest = 100 * time.Millisecond
	retryIntervalForTest  = 10 * time.Millisecond
	pollIntervalForTest   = 5 * time.Millisecond
)

var (
	nonce = uint32(0)

	watcherChains = []vaa.ChainID{vaa.ChainIDPolygon, vaa.ChainIDBSC}
)

func createPerChainQueryForTesting(
	chainId vaa.ChainID,
	block string,
	numCalls int,
) *gossipv1.PerChainQueryRequest {
	callData := []*gossipv1.EthCallQueryRequest_EthCallData{}
	for count := 0; count < numCalls; count++ {
		callData = append(callData, &gossipv1.EthCallQueryRequest_EthCallData{
			To:   []byte(fmt.Sprintf("%-20s", fmt.Sprintf("To for %d:%d", chainId, count))),
			Data: []byte(fmt.Sprintf("CallData for %d:%d", chainId, count)),
		})
	}

	callRequest := &gossipv1.EthCallQueryRequest{
		Block:    block,
		CallData: callData,
	}

	return &gossipv1.PerChainQueryRequest{
		ChainId: uint32(chainId),
		Message: &gossipv1.PerChainQueryRequest_EthCallQueryRequest{
			EthCallQueryRequest: callRequest,
		},
	}
}

func createSignedQueryRequestForTesting(
	sk *ecdsa.PrivateKey,
	perChainQueries []*gossipv1.PerChainQueryRequest,
) (*gossipv1.SignedQueryRequest, *gossipv1.QueryRequest) {
	nonce += 1
	queryRequest := &gossipv1.QueryRequest{
		Nonce:           nonce,
		PerChainQueries: perChainQueries,
	}

	queryRequestBytes, err := proto.Marshal(queryRequest)
	if err != nil {
		panic(err)
	}

	digest := common.QueryRequestDigest(common.UnsafeDevNet, queryRequestBytes)
	sig, err := ethCrypto.Sign(digest.Bytes(), sk)
	if err != nil {
		panic(err)
	}

	signedQueryRequest := &gossipv1.SignedQueryRequest{
		QueryRequest: queryRequestBytes,
		Signature:    sig,
	}

	return signedQueryRequest, queryRequest
}

func createExpectedResultsForTest(perChainQueries []*gossipv1.PerChainQueryRequest) []common.PerChainQueryResponse {
	expectedResults := []common.PerChainQueryResponse{}
	for _, pcq := range perChainQueries {
		switch req := pcq.Message.(type) {
		case *gossipv1.PerChainQueryRequest_EthCallQueryRequest:
			now := time.Now()
			blockNum, err := strconv.ParseInt(strings.TrimPrefix(req.EthCallQueryRequest.Block, "0x"), 16, 64)
			if err != nil {
				panic("invalid blockNum!")
			}
			resp := []common.EthCallQueryResponse{}
			for _, cd := range req.EthCallQueryRequest.CallData {
				resp = append(resp, common.EthCallQueryResponse{
					Number: big.NewInt(blockNum),
					Hash:   ethCommon.HexToHash("0x9999bac44d09a7f69ee7941819b0a19c59ccb1969640cc513be09ef95ed2d8e2"),
					Time:   timeForTest(timeForTest(now)),
					Result: []byte(hex.EncodeToString(cd.To) + ":" + hex.EncodeToString(cd.Data)),
				})
			}
			expectedResults = append(expectedResults, common.PerChainQueryResponse{
				ChainID:   pcq.ChainId,
				Responses: resp,
			})

		default:
			panic("Invalid call data type!")
		}
	}

	return expectedResults
}

// validateResponseForTest performs validation on the responses generated by these tests. Note that it is not a generalized validate function.
func validateResponseForTest(
	t *testing.T,
	response *common.QueryResponsePublication,
	signedRequest *gossipv1.SignedQueryRequest,
	queryRequest *gossipv1.QueryRequest,
	expectedResults []common.PerChainQueryResponse,
) bool {
	require.NotNil(t, response)
	require.True(t, common.SignedQueryRequestEqual(signedRequest, response.Request))
	require.Equal(t, len(queryRequest.PerChainQueries), len(response.PerChainResponses))
	require.True(t, bytes.Equal(response.Request.Signature, signedRequest.Signature))
	require.Equal(t, len(response.PerChainResponses), len(expectedResults))
	for idx := range response.PerChainResponses {
		require.True(t, response.PerChainResponses[idx].Equal(&expectedResults[idx]))
	}

	return true
}

// A timestamp has nanos, but we only marshal down to micros, so trim our time to micros for testing purposes.
func timeForTest(t time.Time) time.Time {
	return time.UnixMicro(t.UnixMicro())
}

func TestCcqParseAllowedRequestersSuccess(t *testing.T) {
	ccqAllowedRequestersList, err := ccqParseAllowedRequesters(testSigner)
	require.NoError(t, err)
	require.NotNil(t, ccqAllowedRequestersList)
	require.Equal(t, 1, len(ccqAllowedRequestersList))

	_, exists := ccqAllowedRequestersList[ethCommon.BytesToAddress(ethCommon.Hex2Bytes(testSigner))]
	require.True(t, exists)
	_, exists = ccqAllowedRequestersList[ethCommon.BytesToAddress(ethCommon.Hex2Bytes("beFA429d57cD18b7F8A4d91A2da9AB4AF05d0FBf"))]
	require.False(t, exists)

	ccqAllowedRequestersList, err = ccqParseAllowedRequesters("beFA429d57cD18b7F8A4d91A2da9AB4AF05d0FBe,beFA429d57cD18b7F8A4d91A2da9AB4AF05d0FBf")
	require.NoError(t, err)
	require.NotNil(t, ccqAllowedRequestersList)
	require.Equal(t, 2, len(ccqAllowedRequestersList))

	_, exists = ccqAllowedRequestersList[ethCommon.BytesToAddress(ethCommon.Hex2Bytes(testSigner))]
	require.True(t, exists)
	_, exists = ccqAllowedRequestersList[ethCommon.BytesToAddress(ethCommon.Hex2Bytes("beFA429d57cD18b7F8A4d91A2da9AB4AF05d0FBf"))]
	require.True(t, exists)
}

func TestCcqParseAllowedRequestersFailsIfParameterEmpty(t *testing.T) {
	ccqAllowedRequestersList, err := ccqParseAllowedRequesters("")
	require.Error(t, err)
	require.Nil(t, ccqAllowedRequestersList)

	ccqAllowedRequestersList, err = ccqParseAllowedRequesters(",")
	require.Error(t, err)
	require.Nil(t, ccqAllowedRequestersList)
}

func TestCcqParseAllowedRequestersFailsIfInvalidParameter(t *testing.T) {
	ccqAllowedRequestersList, err := ccqParseAllowedRequesters("Hello")
	require.Error(t, err)
	require.Nil(t, ccqAllowedRequestersList)
}

type mockData struct {
	sk *ecdsa.PrivateKey

	signedQueryReqReadC  <-chan *gossipv1.SignedQueryRequest
	signedQueryReqWriteC chan<- *gossipv1.SignedQueryRequest

	chainQueryReqC map[vaa.ChainID]chan *common.PerChainQueryInternal

	queryResponseReadC  <-chan *common.PerChainQueryResponseInternal
	queryResponseWriteC chan<- *common.PerChainQueryResponseInternal

	queryResponsePublicationReadC  <-chan *common.QueryResponsePublication
	queryResponsePublicationWriteC chan<- *common.QueryResponsePublication

	mutex                    sync.Mutex
	queryResponsePublication *common.QueryResponsePublication
	expectedResults          []common.PerChainQueryResponse
	requestsPerChain         map[vaa.ChainID]int
	retriesPerChain          map[vaa.ChainID]int
}

// resetState() is used to reset mock data between queries in the same test.
func (md *mockData) resetState() {
	md.mutex.Lock()
	defer md.mutex.Unlock()
	md.queryResponsePublication = nil
	md.expectedResults = nil
	md.requestsPerChain = make(map[vaa.ChainID]int)
	md.retriesPerChain = make(map[vaa.ChainID]int)
}

func (md *mockData) setExpectedResults(expectedResults []common.PerChainQueryResponse) {
	md.mutex.Lock()
	defer md.mutex.Unlock()
	md.expectedResults = expectedResults
}

func (md *mockData) getQueryResponsePublication() *common.QueryResponsePublication {
	md.mutex.Lock()
	defer md.mutex.Unlock()
	return md.queryResponsePublication
}

func (md *mockData) incrementRequestsPerChainAlreadyLocked(chainId vaa.ChainID) {
	if val, exists := md.requestsPerChain[chainId]; exists {
		md.requestsPerChain[chainId] = val + 1
	} else {
		md.requestsPerChain[chainId] = 1
	}
}

func (md *mockData) getRequestsPerChain(chainId vaa.ChainID) int {
	md.mutex.Lock()
	defer md.mutex.Unlock()
	if ret, exists := md.requestsPerChain[chainId]; exists {
		return ret
	}
	return 0
}

func (md *mockData) setRetries(chainId vaa.ChainID, count int) {
	md.mutex.Lock()
	defer md.mutex.Unlock()
	md.retriesPerChain[chainId] = count
}

func (md *mockData) getStatusAlreadyLocked(chainId vaa.ChainID) common.QueryStatus {
	if val, exists := md.retriesPerChain[chainId]; exists {
		if val == fatalError {
			return common.QueryFatalError
		}
		val -= 1
		if val > 0 {
			md.retriesPerChain[chainId] = val
		} else {
			delete(md.retriesPerChain, chainId)
		}
		return common.QueryRetryNeeded
	}
	return common.QuerySuccess
}

func createQueryHandlerForTest(t *testing.T, ctx context.Context, logger *zap.Logger, chains []vaa.ChainID) *mockData {
	md := createQueryHandlerForTestWithoutPublisher(t, ctx, logger, chains)

	// Create a routine that listens for the response and puts it in the mock.
	md.startResponseListener(ctx)

	return md
}

func createQueryHandlerForTestWithoutPublisher(t *testing.T, ctx context.Context, logger *zap.Logger, chains []vaa.ChainID) *mockData {
	md := mockData{}
	var err error

	*unsafeDevMode = true
	md.sk, err = loadGuardianKey("../../hack/query/dev.guardian.key")
	require.NoError(t, err)
	require.NotNil(t, md.sk)

	ccqAllowedRequestersList, err := ccqParseAllowedRequesters(testSigner)
	require.NoError(t, err)

	// Inbound observation requests from the p2p service (for all chains)
	md.signedQueryReqReadC, md.signedQueryReqWriteC = makeChannelPair[*gossipv1.SignedQueryRequest](common.SignedQueryRequestChannelSize)

	// Per-chain query requests
	md.chainQueryReqC = make(map[vaa.ChainID]chan *common.PerChainQueryInternal)
	for _, chainId := range chains {
		md.chainQueryReqC[chainId] = make(chan *common.PerChainQueryInternal)
	}

	// Query responses from watchers to query handler aggregated across all chains
	md.queryResponseReadC, md.queryResponseWriteC = makeChannelPair[*common.PerChainQueryResponseInternal](0)

	// Query responses from query handler to p2p
	md.queryResponsePublicationReadC, md.queryResponsePublicationWriteC = makeChannelPair[*common.QueryResponsePublication](0)

	md.resetState()

	go handleQueryRequestsImpl(ctx, logger, md.signedQueryReqReadC, md.chainQueryReqC, ccqAllowedRequestersList,
		md.queryResponseReadC, md.queryResponsePublicationWriteC, common.GoTest, requestTimeoutForTest, retryIntervalForTest)

	// Create a routine for each configured watcher. It will take a per chain query and return the corresponding expected result.
	// It also pegs a counter of the number of requests the watcher received, for verification purposes.
	for chainId := range md.chainQueryReqC {
		go func(chainId vaa.ChainID, chainQueryReqC <-chan *common.PerChainQueryInternal) {
			for {
				select {
				case <-ctx.Done():
					return
				case pcqr := <-chainQueryReqC:
					require.Equal(t, chainId, pcqr.ChainID)
					md.mutex.Lock()
					md.incrementRequestsPerChainAlreadyLocked(chainId)
					results := md.expectedResults[pcqr.RequestIdx].Responses
					result := md.getStatusAlreadyLocked(chainId)
					logger.Info("watcher returning", zap.String("chainId", chainId.String()), zap.Int("requestIdx", pcqr.RequestIdx), zap.Int("result", int(result)))
					queryResponse := common.CreatePerChainQueryResponseInternal(pcqr.RequestID, pcqr.RequestIdx, pcqr.ChainID, result, results)
					md.queryResponseWriteC <- queryResponse
					md.mutex.Unlock()
				}
			}
		}(chainId, md.chainQueryReqC[chainId])
	}

	return &md
}

func (md *mockData) startResponseListener(ctx context.Context) {
	go func() {
		for {
			select {
			case <-ctx.Done():
				return
			case qrp := <-md.queryResponsePublicationReadC:
				md.mutex.Lock()
				md.queryResponsePublication = qrp
				md.mutex.Unlock()
			}
		}
	}()
}

func (md *mockData) waitForResponse() *common.QueryResponsePublication {
	for count := 0; count < 50; count++ {
		time.Sleep(pollIntervalForTest)
		ret := md.getQueryResponsePublication()
		if ret != nil {
			return ret
		}
	}
	return nil
}

func TestInvalidQueries(t *testing.T) {
	ctx := context.Background()
	logger, err := zap.NewDevelopment()
	require.NoError(t, err)

	md := createQueryHandlerForTest(t, ctx, logger, watcherChains)

	var perChainQueries []*gossipv1.PerChainQueryRequest
	var signedQueryRequest *gossipv1.SignedQueryRequest

	// Query with a bad signature should fail.
	md.resetState()
	perChainQueries = []*gossipv1.PerChainQueryRequest{createPerChainQueryForTesting(vaa.ChainIDPolygon, "0x28d9630", 2)}
	signedQueryRequest, _ = createSignedQueryRequestForTesting(md.sk, perChainQueries)
	signedQueryRequest.Signature[0] += 1 // Corrupt the signature.
	md.signedQueryReqWriteC <- signedQueryRequest
	require.Nil(t, md.waitForResponse())

	// Query for an unsupported chain should fail. The supported chains are defined in supportedChains in query.go
	md.resetState()
	perChainQueries = []*gossipv1.PerChainQueryRequest{createPerChainQueryForTesting(vaa.ChainIDAlgorand, "0x28d9630", 2)}
	signedQueryRequest, _ = createSignedQueryRequestForTesting(md.sk, perChainQueries)
	md.signedQueryReqWriteC <- signedQueryRequest
	require.Nil(t, md.waitForResponse())

	// Query with no per-chain queries should fail.
	md.resetState()
	signedQueryRequest, _ = createSignedQueryRequestForTesting(md.sk, []*gossipv1.PerChainQueryRequest{})
	md.signedQueryReqWriteC <- signedQueryRequest
	require.Nil(t, md.waitForResponse())

	// Query for an invalid chain should fail.
	md.resetState()
	perChainQueries = []*gossipv1.PerChainQueryRequest{createPerChainQueryForTesting(vaa.ChainIDPolygon, "0x28d9630", 2)}
	perChainQueries[0].ChainId = uint32(math.MaxUint16) + 1 // Corrupt the chain ID.
	signedQueryRequest, _ = createSignedQueryRequestForTesting(md.sk, perChainQueries)
	md.signedQueryReqWriteC <- signedQueryRequest
	require.Nil(t, md.waitForResponse())

	// Query for a chain that supports queries but that is not in the watcher channel map should fail.
	md.resetState()
	perChainQueries = []*gossipv1.PerChainQueryRequest{createPerChainQueryForTesting(vaa.ChainIDSepolia, "0x28d9630", 2)}
	signedQueryRequest, _ = createSignedQueryRequestForTesting(md.sk, perChainQueries)
	md.signedQueryReqWriteC <- signedQueryRequest
	require.Nil(t, md.waitForResponse())

	// Query for "latest" should fail.
	md.resetState()
	perChainQueries = []*gossipv1.PerChainQueryRequest{createPerChainQueryForTesting(vaa.ChainIDPolygon, "0x28d9630", 2)}
	switch req := perChainQueries[0].Message.(type) {
	case *gossipv1.PerChainQueryRequest_EthCallQueryRequest:
		req.EthCallQueryRequest.Block = "latest"
	}
	signedQueryRequest, _ = createSignedQueryRequestForTesting(md.sk, perChainQueries)
	md.signedQueryReqWriteC <- signedQueryRequest
	require.Nil(t, md.waitForResponse())

	// A per-chain query with no call data should fail.
	md.resetState()
	perChainQueries = []*gossipv1.PerChainQueryRequest{createPerChainQueryForTesting(vaa.ChainIDPolygon, "0x28d9630", 0)}
	signedQueryRequest, _ = createSignedQueryRequestForTesting(md.sk, perChainQueries)
	md.signedQueryReqWriteC <- signedQueryRequest
	require.Nil(t, md.waitForResponse())

	// Wrong length "To" contract should fail.
	md.resetState()
	perChainQueries = []*gossipv1.PerChainQueryRequest{createPerChainQueryForTesting(vaa.ChainIDPolygon, "0x28d9630", 2)}
	switch req := perChainQueries[0].Message.(type) {
	case *gossipv1.PerChainQueryRequest_EthCallQueryRequest:
		req.EthCallQueryRequest.CallData[0].To = req.EthCallQueryRequest.CallData[0].To[2:]
	}
	signedQueryRequest, _ = createSignedQueryRequestForTesting(md.sk, perChainQueries)
	md.signedQueryReqWriteC <- signedQueryRequest
	require.Nil(t, md.waitForResponse())

	// Invalid type of per-chain query should fail.
	md.resetState()
	perChainQueries = []*gossipv1.PerChainQueryRequest{{ChainId: uint32(vaa.ChainIDPolygon)}}
	signedQueryRequest, _ = createSignedQueryRequestForTesting(md.sk, perChainQueries)
	md.signedQueryReqWriteC <- signedQueryRequest
	require.Nil(t, md.waitForResponse())
}

func TestSingleQueryShouldSucceed(t *testing.T) {
	ctx := context.Background()
	logger, err := zap.NewDevelopment()
	require.NoError(t, err)

	md := createQueryHandlerForTest(t, ctx, logger, watcherChains)

	// Create the request and the expected results. Give the expected results to the mock.
	perChainQueries := []*gossipv1.PerChainQueryRequest{createPerChainQueryForTesting(vaa.ChainIDPolygon, "0x28d9630", 2)}
	signedQueryRequest, queryRequest := createSignedQueryRequestForTesting(md.sk, perChainQueries)
	expectedResults := createExpectedResultsForTest(queryRequest.PerChainQueries)
	md.setExpectedResults(expectedResults)

	// Submit the query request to the handler.
	md.signedQueryReqWriteC <- signedQueryRequest

	// Wait until we receive a response or timeout.
	queryResponsePublication := md.waitForResponse()
	require.NotNil(t, queryResponsePublication)

	assert.Equal(t, 1, md.getRequestsPerChain(vaa.ChainIDPolygon))
	assert.True(t, validateResponseForTest(t, queryResponsePublication, signedQueryRequest, queryRequest, expectedResults))
}

func TestBatchOfTwoQueriesShouldSucceed(t *testing.T) {
	ctx := context.Background()
	logger, err := zap.NewDevelopment()
	require.NoError(t, err)

	md := createQueryHandlerForTest(t, ctx, logger, watcherChains)

	// Create the request and the expected results. Give the expected results to the mock.
	perChainQueries := []*gossipv1.PerChainQueryRequest{
		createPerChainQueryForTesting(vaa.ChainIDPolygon, "0x28d9630", 2),
		createPerChainQueryForTesting(vaa.ChainIDBSC, "0x28d9123", 3),
	}
	signedQueryRequest, queryRequest := createSignedQueryRequestForTesting(md.sk, perChainQueries)
	expectedResults := createExpectedResultsForTest(queryRequest.PerChainQueries)
	md.setExpectedResults(expectedResults)

	// Submit the query request to the handler.
	md.signedQueryReqWriteC <- signedQueryRequest

	// Wait until we receive a response or timeout.
	queryResponsePublication := md.waitForResponse()
	require.NotNil(t, queryResponsePublication)

	assert.Equal(t, 1, md.getRequestsPerChain(vaa.ChainIDPolygon))
	assert.Equal(t, 1, md.getRequestsPerChain(vaa.ChainIDBSC))
	assert.True(t, validateResponseForTest(t, queryResponsePublication, signedQueryRequest, queryRequest, expectedResults))
}

func TestQueryWithLimitedRetriesShouldSucceed(t *testing.T) {
	ctx := context.Background()
	logger, err := zap.NewDevelopment()
	require.NoError(t, err)

	md := createQueryHandlerForTest(t, ctx, logger, watcherChains)

	// Create the request and the expected results. Give the expected results to the mock.
	perChainQueries := []*gossipv1.PerChainQueryRequest{createPerChainQueryForTesting(vaa.ChainIDPolygon, "0x28d9630", 2)}
	signedQueryRequest, queryRequest := createSignedQueryRequestForTesting(md.sk, perChainQueries)
	expectedResults := createExpectedResultsForTest(queryRequest.PerChainQueries)
	md.setExpectedResults(expectedResults)

	// Make it retry a couple of times, but not enough to make it fail.
	retries := 2
	md.setRetries(vaa.ChainIDPolygon, retries)

	// Submit the query request to the handler.
	md.signedQueryReqWriteC <- signedQueryRequest

	// The request should eventually succeed.
	queryResponsePublication := md.waitForResponse()
	require.NotNil(t, queryResponsePublication)

	assert.Equal(t, retries+1, md.getRequestsPerChain(vaa.ChainIDPolygon))
	assert.True(t, validateResponseForTest(t, queryResponsePublication, signedQueryRequest, queryRequest, expectedResults))
}

func TestQueryWithTooManyRetriesShouldFail(t *testing.T) {
	ctx := context.Background()
	logger, err := zap.NewDevelopment()
	require.NoError(t, err)

	md := createQueryHandlerForTest(t, ctx, logger, watcherChains)

	// Create the request and the expected results. Give the expected results to the mock.
	perChainQueries := []*gossipv1.PerChainQueryRequest{
		createPerChainQueryForTesting(vaa.ChainIDPolygon, "0x28d9630", 2),
		createPerChainQueryForTesting(vaa.ChainIDBSC, "0x28d9123", 3),
	}
	signedQueryRequest, queryRequest := createSignedQueryRequestForTesting(md.sk, perChainQueries)
	expectedResults := createExpectedResultsForTest(queryRequest.PerChainQueries)
	md.setExpectedResults(expectedResults)

	// Make polygon retry a couple of times, but not enough to make it fail.
	retriesForPolygon := 2
	md.setRetries(vaa.ChainIDPolygon, retriesForPolygon)

	// Make BSC retry so many times that the request times out.
	md.setRetries(vaa.ChainIDBSC, 1000)

	// Submit the query request to the handler.
	md.signedQueryReqWriteC <- signedQueryRequest

	// The request should timeout.
	queryResponsePublication := md.waitForResponse()
	require.Nil(t, queryResponsePublication)

	assert.Equal(t, retriesForPolygon+1, md.getRequestsPerChain(vaa.ChainIDPolygon))
}

func TestQueryWithLimitedRetriesOnMultipleChainsShouldSucceed(t *testing.T) {
	ctx := context.Background()
	logger, err := zap.NewDevelopment()
	require.NoError(t, err)

	md := createQueryHandlerForTest(t, ctx, logger, watcherChains)

	// Create the request and the expected results. Give the expected results to the mock.
	perChainQueries := []*gossipv1.PerChainQueryRequest{
		createPerChainQueryForTesting(vaa.ChainIDPolygon, "0x28d9630", 2),
		createPerChainQueryForTesting(vaa.ChainIDBSC, "0x28d9123", 3),
	}
	signedQueryRequest, queryRequest := createSignedQueryRequestForTesting(md.sk, perChainQueries)
	expectedResults := createExpectedResultsForTest(queryRequest.PerChainQueries)
	md.setExpectedResults(expectedResults)

	// Make both chains retry a couple of times, but not enough to make it fail.
	retriesForPolygon := 2
	md.setRetries(vaa.ChainIDPolygon, retriesForPolygon)

	retriesForBSC := 3
	md.setRetries(vaa.ChainIDBSC, retriesForBSC)

	// Submit the query request to the handler.
	md.signedQueryReqWriteC <- signedQueryRequest

	// The request should eventually succeed.
	queryResponsePublication := md.waitForResponse()
	require.NotNil(t, queryResponsePublication)

	assert.Equal(t, retriesForPolygon+1, md.getRequestsPerChain(vaa.ChainIDPolygon))
	assert.Equal(t, retriesForBSC+1, md.getRequestsPerChain(vaa.ChainIDBSC))
	assert.True(t, validateResponseForTest(t, queryResponsePublication, signedQueryRequest, queryRequest, expectedResults))
}

func TestFatalErrorOnPerChainQueryShouldCauseRequestToFail(t *testing.T) {
	ctx := context.Background()
	logger, err := zap.NewDevelopment()
	require.NoError(t, err)

	md := createQueryHandlerForTest(t, ctx, logger, watcherChains)

	// Create the request and the expected results. Give the expected results to the mock.
	perChainQueries := []*gossipv1.PerChainQueryRequest{
		createPerChainQueryForTesting(vaa.ChainIDPolygon, "0x28d9630", 2),
		createPerChainQueryForTesting(vaa.ChainIDBSC, "0x28d9123", 3),
	}
	signedQueryRequest, queryRequest := createSignedQueryRequestForTesting(md.sk, perChainQueries)
	expectedResults := createExpectedResultsForTest(queryRequest.PerChainQueries)
	md.setExpectedResults(expectedResults)

	// Make BSC return a fatal error.
	md.setRetries(vaa.ChainIDBSC, fatalError)

	// Submit the query request to the handler.
	md.signedQueryReqWriteC <- signedQueryRequest

	// The request should timeout.
	queryResponsePublication := md.waitForResponse()
	require.Nil(t, queryResponsePublication)

	assert.Equal(t, 1, md.getRequestsPerChain(vaa.ChainIDPolygon))
	assert.Equal(t, 1, md.getRequestsPerChain(vaa.ChainIDBSC))
}

func TestPublishRetrySucceeds(t *testing.T) {
	ctx := context.Background()
	logger, err := zap.NewDevelopment()
	require.NoError(t, err)

	md := createQueryHandlerForTestWithoutPublisher(t, ctx, logger, watcherChains)

	// Create the request and the expected results. Give the expected results to the mock.
	perChainQueries := []*gossipv1.PerChainQueryRequest{createPerChainQueryForTesting(vaa.ChainIDPolygon, "0x28d9630", 2)}
	signedQueryRequest, queryRequest := createSignedQueryRequestForTesting(md.sk, perChainQueries)
	expectedResults := createExpectedResultsForTest(queryRequest.PerChainQueries)
	md.setExpectedResults(expectedResults)

	// Submit the query request to the handler.
	md.signedQueryReqWriteC <- signedQueryRequest

	// Sleep for a bit before we start listening for published results.
	// If you look in the log, you should see one of these: "failed to publish query response to p2p, will retry publishing next interval"
	// and at least one of these: "resend of query response to p2p failed again, will keep retrying".
	time.Sleep(retryIntervalForTest * 3)

	// Now start the publisher routine.
	// If you look in the log, you should see one of these: "resend of query response to p2p succeeded".
	md.startResponseListener(ctx)

	// The response should still get published.
	queryResponsePublication := md.waitForResponse()
	require.NotNil(t, queryResponsePublication)

	assert.Equal(t, 1, md.getRequestsPerChain(vaa.ChainIDPolygon))
	assert.True(t, validateResponseForTest(t, queryResponsePublication, signedQueryRequest, queryRequest, expectedResults))
}
