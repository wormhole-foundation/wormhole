diff --git a/node/cmd/transfer-verifier/transfer-verifier-evm_test.go b/node/cmd/transfer-verifier/transfer-verifier-evm_test.go
index f807863f8..2820b7661 100644
--- a/node/cmd/transfer-verifier/transfer-verifier-evm_test.go
+++ b/node/cmd/transfer-verifier/transfer-verifier-evm_test.go
@@ -26,10 +26,7 @@ import (
 	// "github.com/ethereum/go-ethereum/crypto"// "github.com/stretchr/testify/require"
 )
 
-// Important addresses for testing. Arbitrary, but Ethereum mainnet values used here
 var (
-	coreBridgeAddr  = common.HexToAddress("0x98f3c9e6E3fAce36bAAd05FE09d375Ef1464288B")
-	tokenBridgeAddr = common.HexToAddress("0x3ee18B2214AFF97000D974cf647E7C347E8fa585")
 	erc20Addr       = common.HexToAddress("0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48")
 )
 
@@ -38,6 +35,13 @@ var (
 	eoa = common.HexToAddress("0xbeefcafe")
 )
 
+func init() {
+	// Global variables for the transfer verifier. Arbitrary, but Ethereum mainnet values used here
+	evmCoreBridgeAddr = common.HexToAddress("0x98f3c9e6E3fAce36bAAd05FE09d375Ef1464288B")
+	evmTokenBridgeAddr = common.HexToAddress("0x3ee18B2214AFF97000D974cf647E7C347E8fa585")
+	erc20Addr       = common.HexToAddress("0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48")
+}
+
 // Typical receipt logs that can be included in various receipt test cases
 var (
 	transferLog = &types.Log{
@@ -48,7 +52,7 @@ var (
 			// from
 			common.HexToHash("0x00"), // unused
 			// to
-			tokenBridgeAddr.Hash(),
+			evmTokenBridgeAddr.Hash(),
 		},
 		// amount
 		// TODO this must match Data below
@@ -56,28 +60,14 @@ var (
 	}
 
 	logMessagedPublishedLog = &types.Log{
-		Address: coreBridgeAddr,
+		Address: evmCoreBridgeAddr,
 		Topics: []common.Hash{
 			// LogMessagePublished(address indexed sender, uint64 sequence, uint32 nonce, bytes payload, uint8 consistencyLevel);
 			common.HexToHash(EVENTHASH_WORMHOLE_LOG_MESSAGE_PUBLISHED),
 			// sender
-			tokenBridgeAddr.Hash(),
+			evmTokenBridgeAddr.Hash(),
 		},
-		// NOTE: Make sure the amount here matches with the Data field of `transferLog`
-		// TODO: This was grabbed from an arbitrary transaction on etherscan. We should change this: data
-		// could be populated by doing ABI encoding on values we want to test
-		Data: common.Hex2Bytes(
-			"0000000000000000000000000000000000000000000000000000000000054683" +
-				"0000000000000000000000000000000000000000000000000000000000000000" +
-				"0000000000000000000000000000000000000000000000000000000000000080" +
-				"0000000000000000000000000000000000000000000000000000000000000001" +
-				"0000000000000000000000000000000000000000000000000000000000000085" +
-				"010000000000000000000000000000000000000000000000000000000ba90d68" +
-				"30069b8857feab8184fb687f634618c035dac439dc1aeb3b5598a0f000000000" +
-				"010001ae50701d3669549b204728323f799ae131d966b05ec11198b4d00118de" +
-				"b584720001000000000000000000000000000000000000000000000000000000" +
-				"0000000000000000000000000000000000000000000000000000000000000000",
-		),
+		Data: receiptData(big.NewInt(1)),
 	}
 )
 
@@ -119,10 +109,9 @@ func setup() *mockConnections {
 	ipfslog.SetAllLoggers(ipfslog.LevelDebug)
 
 	var ethConnector connectors.Connector
-	ethConnector, err := connectors.NewEthereumBaseConnector(ctx, "eth", "ws://localhost:8545", coreBridgeAddr, logger)
-	if err != nil {
-		panic(err)
-	}
+	// Silencing the error here because we don't actually need a live RPC connection, just the parsing
+	// methods.
+	ethConnector, _ = connectors.NewEthereumBaseConnector(ctx, "eth", "", evmCoreBridgeAddr, logger)
 	return &mockConnections{
 		logger,
 		&ethConnector,
@@ -131,6 +120,7 @@ func setup() *mockConnections {
 	}
 }
 
+
 func TestProcessReceiptHappyPath(t *testing.T) {
 	mocks := setup()
 	defer mocks.ctxCancel()
@@ -154,7 +144,7 @@ func TestProcessReceiptHappyPath(t *testing.T) {
 		t.Run(name, func(t *testing.T) {
 			t.Log(name)
 
-			numProcessed, err := processReceipt(test.receipt, coreBridgeAddr, tokenBridgeAddr, *mocks.connector, mocks.logger)
+			numProcessed, err := processReceipt(test.receipt, *mocks.connector, mocks.logger)
 			require.NoError(t, err)
 			assert.Equal(t, test.expected, numProcessed)
 		})
@@ -195,7 +185,7 @@ func TestProcessReceiptErrors(t *testing.T) {
 		t.Run(name, func(t *testing.T) {
 			t.Log(name)
 
-			numProcessed, err := processReceipt(test.receipt, coreBridgeAddr, tokenBridgeAddr, *mocks.connector, mocks.logger)
+			numProcessed, err := processReceipt(test.receipt, *mocks.connector, mocks.logger)
 			assert.Equal(t, test.expected, numProcessed)
 			require.Error(t, err)
 		})
@@ -219,12 +209,12 @@ func TestParseERC20TransferEvent(t *testing.T) {
 			topics: []common.Hash{
 				erc20TransferHash,
 				eoa.Hash(),
-				tokenBridgeAddr.Hash(),
+				evmTokenBridgeAddr.Hash(),
 			},
 			data: common.LeftPadBytes([]byte{0x01}, 32),
 			expected: &parsedValues{
 				from:   eoa,
-				to:     tokenBridgeAddr,
+				to:     evmTokenBridgeAddr,
 				amount: new(big.Int).SetBytes([]byte{0x01}),
 			},
 		},
@@ -232,7 +222,7 @@ func TestParseERC20TransferEvent(t *testing.T) {
 			topics: []common.Hash{
 				erc20TransferHash,
 				eoa.Hash(),
-				tokenBridgeAddr.Hash(),
+				evmTokenBridgeAddr.Hash(),
 			},
 			// should be 32 bytes exactly
 			data:     []byte{0x01},
@@ -279,18 +269,18 @@ func TestParseWNativeDepositEvent(t *testing.T) {
 			"well-formed": {
 				topics: []common.Hash{
 					wethDepositHash,
-					tokenBridgeAddr.Hash(),
+					evmTokenBridgeAddr.Hash(),
 				},
 				data: common.LeftPadBytes([]byte{0x01}, 32),
 				expected: &parsedValues{
-					destination: tokenBridgeAddr,
+					destination: evmTokenBridgeAddr,
 					amount:      new(big.Int).SetBytes([]byte{0x01}),
 				},
 			},
 			"data too short": {
 				topics: []common.Hash{
 					wethDepositHash,
-					tokenBridgeAddr.Hash(),
+					evmTokenBridgeAddr.Hash(),
 				},
 				// should be 32 bytes exactly
 				data:     []byte{0x01},
@@ -380,3 +370,49 @@ func TestDenormalize(t *testing.T) {
 		})
 	}
 }
+
+// Generate the Data portion of a LogMessagePublished receipt for use in unit tests.
+func receiptData(payloadAmount *big.Int) (data []byte){
+	// The data below corresponds to values taken from an arbitrary emission from
+	// the core contract. It represents ABI-encoded non-indexed data.
+	// tokenTransfer() payload format:
+	//     transfer.payloadID, uint8, size: 1 
+	//     amount, uint256, size: 32
+	//     tokenAddress, bytes32: size 32
+	//     tokenChain, uint16, size 2
+	//     to, bytes32: size 32
+	//     toChain, uint16, size: 2
+	//     fee, uint256 size: size 32
+	// 1 + 32 + 32 + 2 + 32 + 2 + 32 = 133
+	// See also: https://docs.soliditylang.org/en/latest/abi-spec.html
+
+	// non-payload part of the receipt and ABI metadata fields
+	seq := common.LeftPadBytes([]byte{0x01}, 32)
+	nonce := common.LeftPadBytes([]byte{0x02}, 32)
+	offset := common.LeftPadBytes([]byte{0x80}, 32)
+	consistencyLevel := common.LeftPadBytes([]byte{0x01}, 32)
+	payloadLength := common.LeftPadBytes([]byte{0x85}, 32) // 133 for transferTokens
+	// payload part of the receipt
+	payloadType := []byte{0x01} // transferTokens, not padded
+	amount := common.LeftPadBytes(payloadAmount.Bytes(), 32)
+	tokenAddress := common.LeftPadBytes(erc20Addr.Bytes(), 32)
+	tokenChain := common.LeftPadBytes([]byte{0x02}, 2) // Eth wormhole chain ID, uint16
+	to := common.LeftPadBytes([]byte{0xca, 0xfe}, 32)
+	toChain := common.LeftPadBytes([]byte{0x01}, 2) // Solana wormhole chain ID, uint16
+	fee := common.LeftPadBytes([]byte{0x00}, 32) // Solana wormhole chain ID, uint16
+
+	data = append(data, seq...)
+	data = append(data, nonce...)
+	data = append(data, offset...)
+	data = append(data, consistencyLevel...)
+	data = append(data, payloadLength...)
+	data = append(data, payloadType...)
+	data = append(data, amount...)
+	data = append(data, tokenAddress...)
+	data = append(data, tokenChain...)
+	data = append(data, to...)
+	data = append(data, toChain...)
+	data = append(data, fee...)
+	return data
+
+}
