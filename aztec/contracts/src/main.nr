use dep::aztec::macros::aztec;
mod structs;

/**
To deploy on testnet, use the following commands (following the tutorial):
1. Set the environment variable for the node URL:
export NODE_URL=https://aztec-alpha-testnet-fullnode.zkv.xyz
export SPONSORED_FPC_ADDRESS=0x1260a43ecf03e985727affbbe3e483e60b836ea821b6305bea1c53398b986047
2. Create a new wallets:
2a. Create a new wallet for the owner:
aztec-wallet create-account \
    --register-only \
    --node-url $NODE_URL \
    --alias owner-wallet
2b. Create a new wallet for the receiver:
aztec-wallet create-account \
    --register-only \
    --node-url $NODE_URL \
    --alias receiver-wallet
3. Register owner account with FPC:
3a. Register the owner wallet with the FPC:
aztec-wallet register-contract \
    --node-url $NODE_URL \
    --from owner-wallet \
    --alias sponsoredfpc \
    $SPONSORED_FPC_ADDRESS SponsoredFPC \
    --salt 0
3b. Register the receiver wallet with the FPC:
aztec-wallet register-contract \
    --node-url $NODE_URL \
    --from receiver-wallet \
    --alias sponsoredfpc \
    $SPONSORED_FPC_ADDRESS SponsoredFPC \
    --salt 0
4. Deploy accounts (may get error `Timeout awaiting isMined` but that is fine continue with the next step):
4a. Deploy the owner wallet:
aztec-wallet deploy-account \
    --node-url $NODE_URL \
    --from owner-wallet \
    --payment method=fpc-sponsored,fpc=contracts:sponsoredfpc \
    --register-class
4b. Deploy the receiver wallet:
aztec-wallet deploy-account \
    --node-url $NODE_URL \
    --from receiver-wallet \
    --payment method=fpc-sponsored,fpc=contracts:sponsoredfpc \
    --register-class
5. Deploy the Token contract (wait for it to be mined on testnet check txhash at http://aztecscan.xyz/):
aztec-wallet deploy \
    --node-url $NODE_URL \
    --from accounts:owner-wallet \
    --payment method=fpc-sponsored,fpc=contracts:sponsoredfpc \
    --alias token \
    TokenContract \
    --args accounts:owner-wallet WormToken WORM 18 --no-wait
6. Mint tokens to public & private now to call the upcoming functions:
6a. Mint public tokens:
7. Deploy the Wormhole contract (wait for it to be mined on testnet check txhash at http://aztecscan.xyz/):
aztec-wallet deploy \
    --node-url $NODE_URL \
    --from accounts:owner-wallet \
    --payment method=fpc-sponsored,fpc=contracts:sponsoredfpc \
    --alias wormhole \
    Wormhole \
    --args 13 13 *receiver address* *token contract address* --no-wait
*/

#[aztec]
pub contract Wormhole {
    use crate::structs::{Provider, Guardian, WormholeStorage, Signature};
    use dep::keccak256::keccak256;

    use dep::aztec::{
        macros::{
            functions::{initializer, public, private, internal, utility},
            storage::storage,
        },
        prelude::{Map, PublicMutable, AztecAddress},
        protocol_types::traits::ToField
    };

    use dep::token::Token; 

    // Replace your get_hardcoded_guardians() function with all 19 correct guardians:
    #[utility]
    unconstrained fn get_hardcoded_guardians() -> [crate::structs::Guardian; 19] {
        [
            // Guardian 0: 0xbeFA429d57cD18b7F8A4d91A2da9AB4AF05d0FBe
            crate::structs::Guardian::new(
                [0xbe, 0xfa, 0x42, 0x9d, 0x57, 0xcd, 0x18, 0xb7, 0xf8, 0xa4, 0xd9, 0x1a, 0x2d, 0xa9, 0xab, 0x4a, 0xf0, 0x5d, 0x0f, 0xbe],
                [0xd4, 0xa4, 0x62, 0x99, 0x79, 0xf0, 0xc9, 0xfa, 0x0f, 0x0b, 0xb5, 0x4e, 0xdf, 0x33, 0xf8, 0x7c, 0x8c, 0x5a, 0x1f, 0x42, 0xc0, 0x35, 0x0a, 0x30, 0xd6, 0x8f, 0x7e, 0x96, 0x70, 0x23, 0xe3, 0x4e],
                [0x49, 0x5a, 0x8e, 0xbf, 0x51, 0x01, 0x03, 0x6d, 0x0f, 0xd6, 0x6e, 0x3b, 0x0a, 0x8c, 0x7c, 0x61, 0xb6, 0x5f, 0xce, 0xea, 0xf4, 0x87, 0xab, 0x3c, 0xd1, 0xb5, 0xb7, 0xb5, 0x0b, 0xeb, 0x79, 0x70]
            ),
            // Guardian 1: 0x88D7D8B32a9105d228100E72dFFe2Fae0705D31c
            crate::structs::Guardian::new(
                [0x88, 0xd7, 0xd8, 0xb3, 0x2a, 0x91, 0x05, 0xd2, 0x28, 0x10, 0x0e, 0x72, 0xdf, 0xfe, 0x2f, 0xae, 0x07, 0x05, 0xd3, 0x1c],
                [0xde, 0x95, 0x44, 0xa0, 0x79, 0x98, 0x8d, 0xf1, 0x0b, 0x0c, 0x84, 0x7a, 0x40, 0x18, 0x62, 0xb6, 0x2d, 0x80, 0x74, 0xb0, 0x2b, 0x99, 0x4e, 0xd5, 0xa4, 0xf9, 0x6e, 0x60, 0x78, 0xee, 0x04, 0x8b],
                [0xd5, 0xfd, 0x0b, 0x55, 0xe7, 0x53, 0x45, 0xd6, 0x05, 0x11, 0xe8, 0xd8, 0x22, 0xf8, 0xb6, 0x18, 0xc5, 0xe8, 0xe1, 0xfa, 0x7a, 0x9d, 0xb8, 0x41, 0x01, 0x4a, 0x8a, 0x09, 0x1f, 0x7c, 0x41, 0x19]
            ),
            // Guardian 2: 0x58076F561CC62A47087B567C86f986426dFCD000
            crate::structs::Guardian::new(
                [0x58, 0x07, 0x6f, 0x56, 0x1c, 0xc6, 0x2a, 0x47, 0x08, 0x7b, 0x56, 0x7c, 0x86, 0xf9, 0x86, 0x42, 0x6d, 0xfc, 0xd0, 0x00],
                [0xd0, 0xdd, 0xfb, 0x81, 0xee, 0xd4, 0xd5, 0xcc, 0xbb, 0x87, 0x92, 0x85, 0xc9, 0xe5, 0x26, 0x41, 0xca, 0x72, 0xcc, 0x9e, 0x89, 0xe0, 0x9b, 0x42, 0x36, 0xa1, 0x53, 0x0a, 0xbc, 0xe2, 0xd7, 0x3c],
                [0xfc, 0xc7, 0x2a, 0x3d, 0x05, 0xef, 0xae, 0xc4, 0x00, 0xe7, 0xec, 0xa3, 0xdc, 0xb2, 0xbb, 0x6d, 0xdf, 0x5e, 0x1f, 0x79, 0x8f, 0x8c, 0x3f, 0xa3, 0xde, 0x97, 0xfd, 0x71, 0xd4, 0xe3, 0x3a, 0xa0]
            ),
            // Guardian 3: 0xBd6e9833490F8fA87c733A183CD076a6cBD29074
            crate::structs::Guardian::new(
                [0xbd, 0x6e, 0x98, 0x33, 0x49, 0x0f, 0x8f, 0xa8, 0x7c, 0x73, 0x3a, 0x18, 0x3c, 0xd0, 0x76, 0xa6, 0xcb, 0xd2, 0x90, 0x74],
                [0x12, 0x08, 0x13, 0x27, 0xa0, 0x56, 0x66, 0xbb, 0x31, 0x51, 0x0a, 0x69, 0x30, 0xb0, 0x5d, 0x9b, 0x10, 0x3d, 0xc3, 0x6f, 0x47, 0xbc, 0x5b, 0xbd, 0x85, 0x81, 0x62, 0xe0, 0xbd, 0xfd, 0xfc, 0x7f],
                [0xe9, 0x44, 0xd4, 0x06, 0xd1, 0x73, 0xa5, 0x4d, 0x57, 0x36, 0x6a, 0xae, 0x6a, 0x0c, 0xb8, 0x05, 0xea, 0x59, 0x42, 0xb7, 0x14, 0xf6, 0x4b, 0xfc, 0x05, 0x7a, 0xca, 0x35, 0xb6, 0x26, 0x59, 0x67]
            ),
            // Guardian 4: 0xb853FCF0a5C78C1b56D15fCE7a154e6ebe9ED7a2
            crate::structs::Guardian::new(
                [0xb8, 0x53, 0xfc, 0xf0, 0xa5, 0xc7, 0x8c, 0x1b, 0x56, 0xd1, 0x5f, 0xce, 0x7a, 0x15, 0x4e, 0x6e, 0xbe, 0x9e, 0xd7, 0xa2],
                [0x3a, 0xb8, 0x10, 0x4c, 0x4b, 0xa4, 0xb5, 0xed, 0xd1, 0x83, 0xa8, 0x09, 0x83, 0x1b, 0x1e, 0xad, 0x4f, 0x54, 0x0a, 0xb6, 0x23, 0x28, 0x10, 0x12, 0x92, 0x8b, 0xc7, 0xb2, 0x6c, 0xd1, 0xd3, 0x43],
                [0xe0, 0xe2, 0x81, 0x85, 0x53, 0x16, 0xbd, 0x89, 0x9f, 0x1e, 0x47, 0xa2, 0xd6, 0x3a, 0x58, 0x78, 0xac, 0x6c, 0xbb, 0xe5, 0x3a, 0x57, 0xb0, 0x3a, 0xd6, 0x64, 0xf0, 0xf1, 0xa7, 0xb7, 0xb6, 0x00]
            ),
            // Guardian 5: 0xAF3503dBD2E37518ab04D7CE78b630F98b15b78a
            crate::structs::Guardian::new(
                [0xaf, 0x35, 0x03, 0xdb, 0xd2, 0xe3, 0x75, 0x18, 0xab, 0x04, 0xd7, 0xce, 0x78, 0xb6, 0x30, 0xf9, 0x8b, 0x15, 0xb7, 0x8a],
                [0x47, 0x54, 0x1e, 0x77, 0xc1, 0xff, 0xbd, 0x34, 0xed, 0x66, 0x6a, 0x2d, 0x86, 0xaa, 0x84, 0xc3, 0x72, 0xd5, 0x4c, 0x3e, 0x61, 0x1b, 0xa2, 0xbc, 0xcb, 0xcf, 0xad, 0xb5, 0xfa, 0xac, 0x5c, 0x16],
                [0x39, 0x5b, 0x75, 0xee, 0x6a, 0x49, 0xf9, 0xdd, 0x5a, 0x4d, 0xc2, 0xd2, 0xfd, 0xc2, 0x8e, 0x4f, 0xa7, 0x4e, 0x38, 0x8e, 0x85, 0xa6, 0x89, 0x78, 0x58, 0xff, 0x28, 0x64, 0x4b, 0x9d, 0x87, 0x84]
            ),
            // Guardian 6: 0x785632deA5609064803B1c8EA8bB2c77a6004Bd1
            crate::structs::Guardian::new(
                [0x78, 0x56, 0x32, 0xde, 0xa5, 0x60, 0x90, 0x64, 0x80, 0x3b, 0x1c, 0x8e, 0xa8, 0xbb, 0x2c, 0x77, 0xa6, 0x00, 0x4b, 0xd1],
                [0xba, 0xc0, 0x4f, 0x86, 0x0a, 0x22, 0x87, 0x40, 0x2a, 0x36, 0xda, 0xa7, 0x1e, 0xee, 0xeb, 0x46, 0x18, 0x87, 0x66, 0xf2, 0x46, 0x3a, 0x56, 0xc6, 0x84, 0x17, 0x1b, 0xd5, 0xed, 0xfb, 0xd7, 0xba],
                [0x3d, 0xea, 0xac, 0x57, 0x4e, 0xc0, 0x93, 0x98, 0x27, 0x86, 0x0b, 0x03, 0x1d, 0x97, 0x47, 0xd2, 0x16, 0x3c, 0xa5, 0x34, 0xa0, 0x3e, 0x84, 0x0d, 0x4c, 0xe9, 0xa4, 0xd0, 0x65, 0xff, 0x9a, 0xa6]
            ),
            // Guardian 7: 0x09a281a698C0F5BA31f158585B41F4f33659e54D
            crate::structs::Guardian::new(
                [0x09, 0xa2, 0x81, 0xa6, 0x98, 0xc0, 0xf5, 0xba, 0x31, 0xf1, 0x58, 0x58, 0x5b, 0x41, 0xf4, 0xf3, 0x36, 0x59, 0xe5, 0x4d],
                [0xfa, 0x0c, 0x20, 0x46, 0x33, 0x38, 0x6e, 0x43, 0x67, 0xd1, 0x0b, 0xda, 0x6a, 0x2a, 0xcd, 0x83, 0x24, 0x31, 0xc1, 0x2c, 0x7c, 0x90, 0x0a, 0xfc, 0x17, 0x45, 0xed, 0x3c, 0x75, 0x48, 0x65, 0xd3],
                [0x7b, 0xfe, 0xaf, 0xc6, 0x07, 0xda, 0x4b, 0x79, 0xd2, 0x0e, 0xb7, 0xb0, 0xce, 0x14, 0x9e, 0xf0, 0x95, 0x99, 0x63, 0x0c, 0x11, 0x9f, 0x8c, 0xee, 0xba, 0x27, 0x23, 0x93, 0x76, 0xcd, 0xb4, 0x50]
            ),
            // Guardian 8: 0x3178443AB76a60E21690DBfB17f7F59F09Ae3Ea1
            crate::structs::Guardian::new(
                [0x31, 0x78, 0x44, 0x3a, 0xb7, 0x6a, 0x60, 0xe2, 0x16, 0x90, 0xdb, 0xfb, 0x17, 0xf7, 0xf5, 0x9f, 0x09, 0xae, 0x3e, 0xa1],
                [0x30, 0xb8, 0x67, 0xbd, 0xd0, 0xaf, 0x1b, 0xa2, 0x7e, 0xc3, 0x90, 0xa8, 0x5f, 0x4b, 0xce, 0x0b, 0x05, 0xfa, 0xea, 0xe6, 0x0f, 0x60, 0xae, 0x93, 0x69, 0x28, 0x16, 0x69, 0x5e, 0x5b, 0x3e, 0x33],
                [0xa6, 0x63, 0x7e, 0x6f, 0x90, 0xba, 0xde, 0x3f, 0xc7, 0x17, 0xe1, 0x85, 0x4f, 0x99, 0x18, 0x18, 0x28, 0xf2, 0x57, 0x98, 0xd8, 0x41, 0xc4, 0xf7, 0x8e, 0xdf, 0x67, 0x62, 0xa8, 0x91, 0xf1, 0x10]
            ),
            // Guardian 9: 0x647ec26ae49b14060660504f4DA1c2059E1C5Ab6
            crate::structs::Guardian::new(
                [0x64, 0x7e, 0xc2, 0x6a, 0xe4, 0x9b, 0x14, 0x06, 0x06, 0x60, 0x50, 0x4f, 0x4d, 0xa1, 0xc2, 0x05, 0x9e, 0x1c, 0x5a, 0xb6],
                [0x83, 0xe2, 0x58, 0xec, 0xc3, 0xf9, 0xde, 0xb6, 0x89, 0x10, 0x0c, 0x83, 0x1d, 0x4d, 0xe3, 0xe7, 0x21, 0x9d, 0x6e, 0x72, 0x46, 0x6c, 0x68, 0x21, 0x48, 0xcb, 0x58, 0xf9, 0x34, 0x3b, 0x4b, 0xbd],
                [0x81, 0xe1, 0x1d, 0x1f, 0x33, 0xd3, 0xd4, 0xdc, 0xa0, 0x40, 0x45, 0xa5, 0x0c, 0x07, 0x1f, 0xc5, 0xbe, 0xb3, 0xf9, 0x76, 0x2f, 0xce, 0x79, 0x26, 0x0e, 0xdd, 0x75, 0x90, 0xbd, 0xdf, 0x8b, 0x7b]
            ),
            // Guardian 10: 0x810AC3D8E1258Bd2F004a94Ca0cd4c68Fc1C0611
            crate::structs::Guardian::new(
                [0x81, 0x0a, 0xc3, 0xd8, 0xe1, 0x25, 0x8b, 0xd2, 0xf0, 0x04, 0xa9, 0x4c, 0xa0, 0xcd, 0x4c, 0x68, 0xfc, 0x1c, 0x06, 0x11],
                [0xe7, 0xe3, 0x2b, 0xe9, 0xaf, 0x97, 0x7a, 0xd0, 0x8a, 0xa3, 0x7a, 0x1f, 0xab, 0x32, 0xca, 0x4b, 0x66, 0x89, 0x08, 0x16, 0xa9, 0x48, 0x39, 0x7e, 0x54, 0xa6, 0x3c, 0xcf, 0xa5, 0xd6, 0xd9, 0x2e],
                [0x00, 0x30, 0xc2, 0x87, 0x44, 0x01, 0xc8, 0x58, 0xc1, 0x71, 0x03, 0x73, 0x24, 0x6c, 0xa4, 0xe3, 0x9b, 0x8f, 0x59, 0xd3, 0x42, 0x27, 0x8e, 0x43, 0x42, 0x32, 0x1d, 0x5e, 0xb3, 0x67, 0xc5, 0x48]
            ),
            // Guardian 11: 0x80610e96d645b12f47ae5cf4546b18538739e90F
            crate::structs::Guardian::new(
                [0x80, 0x61, 0x0e, 0x96, 0xd6, 0x45, 0xb1, 0x2f, 0x47, 0xae, 0x5c, 0xf4, 0x54, 0x6b, 0x18, 0x53, 0x87, 0x39, 0xe9, 0x0f],
                [0x45, 0x6d, 0xfd, 0x9d, 0x19, 0xcc, 0x9d, 0x7d, 0x64, 0x9d, 0x7a, 0x2d, 0xa1, 0x19, 0x31, 0x47, 0x15, 0x07, 0xd5, 0x6d, 0x95, 0xd0, 0x0b, 0x35, 0x1e, 0x9e, 0x5b, 0x5c, 0x52, 0x19, 0x29, 0xd1],
                [0x94, 0x47, 0xf0, 0xc5, 0x01, 0x77, 0x6d, 0x34, 0xbf, 0x25, 0x35, 0xa1, 0xe2, 0xb1, 0x70, 0x58, 0xb4, 0xa0, 0x16, 0xb7, 0x24, 0x37, 0x2d, 0xc4, 0xcc, 0x87, 0xa7, 0x06, 0x13, 0x99, 0xd0, 0x6f]
            ),
            // Guardian 12: 0x2edb0D8530E31A218E72B9480202AcBaeB06178d
            crate::structs::Guardian::new(
                [0x2e, 0xdb, 0x0d, 0x85, 0x30, 0xe3, 0x1a, 0x21, 0x8e, 0x72, 0xb9, 0x48, 0x02, 0x02, 0xac, 0xba, 0xeb, 0x06, 0x17, 0x8d],
                [0xac, 0x8e, 0x60, 0xae, 0xda, 0x22, 0xb4, 0x70, 0xf6, 0x25, 0x50, 0x62, 0xff, 0x7e, 0x29, 0xfc, 0x74, 0xc2, 0x62, 0x90, 0xa7, 0x1a, 0xd6, 0xf5, 0xb6, 0xc3, 0xc5, 0xcb, 0xa2, 0x8a, 0x73, 0x4b],
                [0xce, 0x67, 0x33, 0x23, 0x2a, 0xeb, 0xa9, 0x31, 0xe5, 0x67, 0xb1, 0x67, 0xe5, 0x9e, 0x8b, 0x07, 0x42, 0xee, 0x16, 0x0a, 0x5e, 0xfc, 0x21, 0x2a, 0x9e, 0x66, 0xf1, 0x90, 0x1c, 0x16, 0xb3, 0x3b]
            ),
            // Guardian 13: 0xa78858e5e5c4705CdD4B668FFe3Be5bae4867c9D
            crate::structs::Guardian::new(
                [0xa7, 0x88, 0x58, 0xe5, 0xe5, 0xc4, 0x70, 0x5c, 0xdd, 0x4b, 0x66, 0x8f, 0xfe, 0x3b, 0xe5, 0xba, 0xe4, 0x86, 0x7c, 0x9d],
                [0xb8, 0x82, 0xd0, 0xbf, 0xac, 0xa1, 0x0c, 0x6e, 0x37, 0x85, 0xc1, 0xf5, 0xe9, 0x47, 0x3f, 0xf8, 0x3c, 0x35, 0x2c, 0xbf, 0x9c, 0xa6, 0x1d, 0x0d, 0x44, 0x61, 0x3c, 0x24, 0xb8, 0x61, 0x3e, 0x01],
                [0x92, 0x1f, 0x32, 0x02, 0x14, 0x86, 0x47, 0x07, 0x18, 0x17, 0xac, 0x85, 0xcb, 0x84, 0x13, 0xc5, 0x57, 0x63, 0xd3, 0x4d, 0xf5, 0xc9, 0xfd, 0x66, 0x1b, 0xc6, 0x90, 0xcf, 0x59, 0x21, 0xff, 0x16]
            ),
            // Guardian 14: 0x5Efe3A05Efc62D60e1D19fAeB56A80223CDd3472
            crate::structs::Guardian::new(
                [0x5e, 0xfe, 0x3a, 0x05, 0xef, 0xc6, 0x2d, 0x60, 0xe1, 0xd1, 0x9f, 0xae, 0xb5, 0x6a, 0x80, 0x22, 0x3c, 0xdd, 0x34, 0x72],
                [0x9a, 0xf4, 0x5b, 0x27, 0x0b, 0x79, 0xfe, 0xf7, 0xad, 0x1f, 0x97, 0xce, 0xfa, 0x09, 0xa3, 0x49, 0x22, 0x95, 0x48, 0x4c, 0x99, 0x0c, 0x3a, 0x07, 0x12, 0xcf, 0x6e, 0xe4, 0x7f, 0xe2, 0x88, 0x72],
                [0x87, 0x1f, 0x97, 0x13, 0x5e, 0x1e, 0xf3, 0x2a, 0xc9, 0xff, 0x2d, 0x6f, 0x4e, 0x15, 0xd0, 0x9c, 0xb2, 0x73, 0x68, 0x8a, 0x4b, 0x8c, 0xe6, 0xf8, 0x3d, 0xe1, 0x9c, 0xb8, 0xe9, 0x6d, 0xe9, 0x50]
            ),
            // Guardian 15: 0xD791b7D32C05aBB1cc00b6381FA0c4928f0c56fC
            crate::structs::Guardian::new(
                [0xd7, 0x91, 0xb7, 0xd3, 0x2c, 0x05, 0xab, 0xb1, 0xcc, 0x00, 0xb6, 0x38, 0x1f, 0xa0, 0xc4, 0x92, 0x8f, 0x0c, 0x56, 0xfc],
                [0x0e, 0x49, 0xf3, 0xcc, 0x63, 0x85, 0x69, 0x20, 0xb9, 0xaa, 0xf9, 0x26, 0x14, 0x2c, 0x72, 0x1d, 0x2d, 0xad, 0x2a, 0x32, 0xe7, 0xe5, 0x1d, 0xf6, 0x20, 0xcf, 0x2d, 0x37, 0x9c, 0xd6, 0x2a, 0xb3],
                [0x73, 0x8e, 0x28, 0xf3, 0x16, 0x35, 0xcc, 0x75, 0xc6, 0xfb, 0xd1, 0x43, 0xc1, 0x0b, 0x98, 0xad, 0xc8, 0x14, 0xc6, 0x31, 0x9b, 0x81, 0xf5, 0x7c, 0x47, 0xa5, 0x55, 0xb2, 0x85, 0x76, 0x62, 0x03]
            ),
            // Guardian 16: 0x14Bc029B8809069093D712A3fd4DfAb31963597e
            crate::structs::Guardian::new(
                [0x14, 0xbc, 0x02, 0x9b, 0x88, 0x09, 0x06, 0x90, 0x93, 0xd7, 0x12, 0xa3, 0xfd, 0x4d, 0xfa, 0xb3, 0x19, 0x63, 0x59, 0x7e],
                [0xb2, 0x17, 0x04, 0xa6, 0xa0, 0x7d, 0xa3, 0x57, 0xc9, 0xd2, 0x37, 0x68, 0xb8, 0x89, 0xbb, 0x57, 0xa6, 0xd2, 0x20, 0xad, 0x70, 0x61, 0x5c, 0xd8, 0xb7, 0xee, 0x82, 0x3c, 0x84, 0xd7, 0x72, 0x62],
                [0xeb, 0x49, 0x46, 0xcb, 0xfe, 0x2e, 0x73, 0xb9, 0x65, 0xe0, 0x59, 0x19, 0xa2, 0x70, 0x5d, 0xbe, 0xa9, 0xfd, 0xf2, 0xe1, 0xbe, 0xde, 0x0b, 0xb0, 0x73, 0xfd, 0x52, 0x1f, 0xa3, 0x85, 0xcb, 0xef]
            ),
            // Guardian 17: 0x246Ab29FC6EBeDf2D392a51ab2Dc5C59d0902A03
            crate::structs::Guardian::new(
                [0x24, 0x6a, 0xb2, 0x9f, 0xc6, 0xeb, 0xed, 0xf2, 0xd3, 0x92, 0xa5, 0x1a, 0xb2, 0xdc, 0x5c, 0x59, 0xd0, 0x90, 0x2a, 0x03],
                [0x53, 0xcd, 0x43, 0x54, 0xfd, 0x30, 0x6a, 0xe2, 0x1b, 0x46, 0x99, 0xdb, 0x7e, 0xeb, 0xc7, 0x4c, 0xd8, 0x5f, 0x71, 0x3a, 0x6e, 0x9a, 0x6a, 0x86, 0x14, 0xea, 0xfe, 0x61, 0x7f, 0x3b, 0x66, 0xf6],
                [0xa8, 0xa6, 0xb3, 0x5c, 0x35, 0xc1, 0x02, 0xe0, 0x9b, 0xcd, 0xb5, 0x19, 0xc1, 0xea, 0x9f, 0xfc, 0x9f, 0x47, 0xb7, 0xd5, 0x9b, 0x2b, 0x04, 0xfb, 0x55, 0xa1, 0x90, 0xbf, 0xa5, 0x6e, 0xc2, 0x08]
            ),
            // Guardian 18: 0x132A84dFD920b35a3D0BA5f7A0635dF298F9033e
            crate::structs::Guardian::new(
                [0x13, 0x2a, 0x84, 0xdf, 0xd9, 0x20, 0xb3, 0x5a, 0x3d, 0x0b, 0xa5, 0xf7, 0xa0, 0x63, 0x5d, 0xf2, 0x98, 0xf9, 0x03, 0x3e],
                [0xad, 0x7a, 0x5a, 0xca, 0x2a, 0xa2, 0x23, 0x5c, 0xc4, 0x3e, 0x3b, 0x4f, 0x0c, 0xe6, 0x0d, 0x83, 0xc6, 0xb1, 0x7b, 0x9b, 0xbe, 0x16, 0xbd, 0xb4, 0x2b, 0xac, 0x9a, 0xad, 0x1b, 0xbb, 0x85, 0xe1],
                [0x9f, 0xb5, 0x12, 0x3c, 0x61, 0x02, 0xe6, 0xa0, 0xab, 0x1b, 0x64, 0x8a, 0x1d, 0xef, 0x10, 0xf4, 0x6a, 0xe3, 0x79, 0x58, 0x8a, 0x36, 0xea, 0xa4, 0x56, 0x1e, 0xed, 0x6d, 0xf0, 0xa5, 0x8c, 0xe0]
            )
        ]
    }

    #[utility]
    unconstrained fn get_guardian_by_index_unconstrained(guardian_idx: u8, guardians: [crate::structs::Guardian; 19]) -> crate::structs::Guardian {
        if guardian_idx < 19 {
            guardians[guardian_idx as u32]
        } else {
            crate::structs::Guardian::default()
        }
    }

    #[utility]
    unconstrained fn parse_vaa_unconstrained(bytes: [u8; 2000], actual_length: u32) -> (u32, u8, [[u8; 66]; 13], [u8; 1860], u32) {
        let guardian_set_index: u32 = (bytes[1] as u32) << 24 | 
                                    (bytes[2] as u32) << 16 | 
                                    (bytes[3] as u32) << 8 | 
                                    (bytes[4] as u32);
        
        let signatures_len = bytes[5];
        
        // Parse signatures
        let mut signatures = [[0; 66]; 13];
        for i in 0..13 {
            if i < signatures_len {
                let sig_start: u32 = 6 + (i as u32 * 66);
                for j in 0..66 {
                    let byte_index: u32 = sig_start + j as u32;
                    if byte_index < actual_length {
                        signatures[i as u32][j] = bytes[byte_index];
                    }
                }
            }
        }

        // Calculate where the body starts
        let body_start: u32 = 6 + (signatures_len as u32 * 66);
        
        // Calculate actual body length
        let body_length: u32 = actual_length - body_start;
        
        let mut body_bytes = [0; 1860];
        for i in 0..1860 {
            if i < body_length {
                body_bytes[i] = bytes[body_start + i];
            }
        }

        (guardian_set_index, signatures_len, signatures, body_bytes, body_length)
    }

    #[utility]
    unconstrained fn compute_vaa_hash_unconstrained(body_bytes: [u8; 1860], body_length: u32) -> [u8; 32] {
        // Extract only the actual body content
        let mut actual_body = [0; 1860];
        for i in 0..body_length {
            actual_body[i] = body_bytes[i];
        }
        
        // Double hash as per Wormhole spec
        let hash: [u8; 32] = keccak256(actual_body, body_length);
        let double_hash: [u8; 32] = keccak256(hash, 32);
        
        double_hash
    }


    #[storage]
    struct Storage<Context> {
        state: PublicMutable<WormholeStorage, Context>,
        sequences: Map<AztecAddress, PublicMutable<u64, Context>, Context>,
        wormhole_address: PublicMutable<AztecAddress, Context>,
        token_address: PublicMutable<AztecAddress, Context>,
        guardian_1: Map<u32, PublicMutable<Guardian, Context>, Context>,
        guardian_2: Map<u32, PublicMutable<Guardian, Context>, Context>,
        guardian_3: Map<u32, PublicMutable<Guardian, Context>, Context>,
        guardian_4: Map<u32, PublicMutable<Guardian, Context>, Context>,
        guardian_5: Map<u32, PublicMutable<Guardian, Context>, Context>,
        guardian_6: Map<u32, PublicMutable<Guardian, Context>, Context>,
        guardian_7: Map<u32, PublicMutable<Guardian, Context>, Context>,
        guardian_8: Map<u32, PublicMutable<Guardian, Context>, Context>,
        guardian_9: Map<u32, PublicMutable<Guardian, Context>, Context>,
        guardian_10: Map<u32, PublicMutable<Guardian, Context>, Context>,
        guardian_11: Map<u32, PublicMutable<Guardian, Context>, Context>,
        guardian_12: Map<u32, PublicMutable<Guardian, Context>, Context>,
        guardian_13: Map<u32, PublicMutable<Guardian, Context>, Context>,
        guardian_14: Map<u32, PublicMutable<Guardian, Context>, Context>,
        guardian_15: Map<u32, PublicMutable<Guardian, Context>, Context>,
        guardian_16: Map<u32, PublicMutable<Guardian, Context>, Context>,
        guardian_17: Map<u32, PublicMutable<Guardian, Context>, Context>,
        guardian_18: Map<u32, PublicMutable<Guardian, Context>, Context>,
        guardian_19: Map<u32, PublicMutable<Guardian, Context>, Context>,
        current_guardian_set_index: Map<u32, PublicMutable<u64, Context>, Context>,
    }

    #[public]
    #[initializer]
    fn init(
        chain_id: u16,
        evm_chain_id: u16,
        wormhole_address: AztecAddress, 
        token_address: AztecAddress, 
    ) {
        let provider: Provider = Provider {
            chain_id,
            evm_chain_id,
        };
        storage.state.write(WormholeStorage::init(provider));
        storage.wormhole_address.write(wormhole_address);
        storage.token_address.write(token_address);
        storage.current_guardian_set_index.at(0).write(18_446_744_073_709_551_615);
    }

    #[public]
    fn publish_message_in_public(
        nonce: u64,
        payloads: [[u8; 31]; 8], 
        message_fee: u128,
        consistency: u8,
        from: AztecAddress,
        token_nonce: Field,
    ) -> u64 {
        assert(storage.state.read().message_fee <= message_fee, "insufficient fee");

        let receiver_address = storage.wormhole_address.read();
        let token_address = storage.token_address.read();

        let _ = Token::at(token_address).transfer_in_public(
            from,
            receiver_address, 
            message_fee,
            token_nonce,  
        ).call(&mut context);

        let sequence = storage.sequences.at(context.msg_sender()).read();
        storage.sequences.at(context.msg_sender()).write(sequence + 1);

        let msg: [Field; 13] = [
            context.msg_sender().to_field(), 
            sequence as Field,  
            nonce as Field,
            consistency as Field, 
            context.timestamp() as Field,
            Field::from_le_bytes(payloads[0]),
            Field::from_le_bytes(payloads[1]),
            Field::from_le_bytes(payloads[2]),
            Field::from_le_bytes(payloads[3]),
            Field::from_le_bytes(payloads[4]),
            Field::from_le_bytes(payloads[5]),
            Field::from_le_bytes(payloads[6]),
            Field::from_le_bytes(payloads[7]),
        ];

        context.emit_public_log(msg);
        sequence
    }

    #[private]
    fn publish_message_in_private(
        nonce: u64,
        payloads: [[u8; 31]; 8], 
        message_fee: u128,
        consistency: u8,
        from: AztecAddress, 
        token_nonce: Field,
    ) {
        assert(1 <= message_fee, "insufficient fee");

        let receiver_address = AztecAddress {
            inner: 0x1f41267c06dae96c9c3906c5f77cbc28602cc70d6d7e9d2c3072cb0a5b13edd2
        };
        let token_address = AztecAddress {
            inner: 0x13cbdd508896505ef168ccd64a757bb91e1ddb89c737973d2c596961af73ce8e
        };

        let _ = Token::at(token_address).transfer_in_private(
            from,
            receiver_address, 
            message_fee,
            token_nonce,  
        ).call(&mut context);

        Wormhole::at(context.this_address())._publish_message(
            nonce, 
            payloads, 
            consistency
        ).enqueue(&mut context);
    }

    #[public]
    #[internal]
    fn _publish_message(
        nonce: u64,
        payloads: [[u8; 31]; 8], 
        consistency: u8,
    ) -> u64 {
        let sequence = storage.sequences.at(context.msg_sender()).read();
        storage.sequences.at(context.msg_sender()).write(sequence + 1);

        let msg: [Field; 13] = [
            context.msg_sender().to_field(), 
            sequence as Field,  
            nonce as Field,
            consistency as Field, 
            context.timestamp() as Field,
            Field::from_le_bytes(payloads[0]),
            Field::from_le_bytes(payloads[1]),
            Field::from_le_bytes(payloads[2]),
            Field::from_le_bytes(payloads[3]),
            Field::from_le_bytes(payloads[4]),
            Field::from_le_bytes(payloads[5]),
            Field::from_le_bytes(payloads[6]),
            Field::from_le_bytes(payloads[7]),
        ];

        context.emit_public_log(msg);
        sequence
    }

    // Keep all your guardian setters exactly as they are
    #[public]
    fn set_guardian1(guardian: Guardian, index: u32) { 
        storage.guardian_1.at(index).write(guardian);
    }

    #[public]
    fn set_guardian2(guardian: Guardian, index: u32) { 
        storage.guardian_2.at(index).write(guardian);
    }

    #[public]
    fn set_guardian3(guardian: Guardian, index: u32) { 
        storage.guardian_3.at(index).write(guardian);
    }

    #[public]
    fn set_guardian4(guardian: Guardian, index: u32) { 
        storage.guardian_4.at(index).write(guardian);
    }

    #[public]
    fn set_guardian5(guardian: Guardian, index: u32) { 
        storage.guardian_5.at(index).write(guardian);
    }

    #[public]
    fn set_guardian6(guardian: Guardian, index: u32) { 
        storage.guardian_6.at(index).write(guardian);
    }

    #[public]
    fn set_guardian7(guardian: Guardian, index: u32) { 
        storage.guardian_7.at(index).write(guardian);
    }

    #[public]
    fn set_guardian8(guardian: Guardian, index: u32) { 
        storage.guardian_8.at(index).write(guardian);
    }

    #[public]
    fn set_guardian9(guardian: Guardian, index: u32) { 
        storage.guardian_9.at(index).write(guardian);
    }

    #[public]
    fn set_guardian10(guardian: Guardian, index: u32) { 
        storage.guardian_10.at(index).write(guardian);
    }

    #[public]
    fn set_guardian11(guardian: Guardian, index: u32) { 
        storage.guardian_11.at(index).write(guardian);
    }

    #[public]
    fn set_guardian12(guardian: Guardian, index: u32) { 
        storage.guardian_12.at(index).write(guardian);
    }

    #[public]
    fn set_guardian13(guardian: Guardian, index: u32) { 
        storage.guardian_13.at(index).write(guardian);
    }

    #[public]
    fn set_guardian14(guardian: Guardian, index: u32) { 
        storage.guardian_14.at(index).write(guardian);
    }

    #[public]
    fn set_guardian15(guardian: Guardian, index: u32) { 
        storage.guardian_15.at(index).write(guardian);
    }

    #[public]
    fn set_guardian16(guardian: Guardian, index: u32) { 
        storage.guardian_16.at(index).write(guardian);
    }

    #[public]
    fn set_guardian17(guardian: Guardian, index: u32) { 
        storage.guardian_17.at(index).write(guardian);
    }

    #[public]
    fn set_guardian18(guardian: Guardian, index: u32) { 
        storage.guardian_18.at(index).write(guardian);
    }

    #[public]
    fn set_guardian19(guardian: Guardian, index: u32) { 
        storage.guardian_19.at(index).write(guardian);
    }

    #[public]
    fn expire_guardian_set(index: u32) {
        storage.current_guardian_set_index.at(index).write(context.timestamp() + 86400);
    }

    #[public]
    fn guardian_set_expired(index: u32) -> bool {
        let timestamp = storage.current_guardian_set_index.at(index).read();
        context.timestamp() > timestamp
    }

    #[public]
    fn set_provider(provider: Provider) {
        let updated_storage = WormholeStorage::set_provider(storage.state.read(), provider);
        storage.state.write(updated_storage);
    }

    #[public]
    fn get_provider() -> Provider {
        WormholeStorage::get_provider(storage.state.read())
    }

    #[utility]
    unconstrained fn verify_vaa_unconstrained(bytes: [u8; 2000], actual_length: u32) -> ([[u8; 32]; 13], [[u8; 32]; 13], [[u8; 64]; 13], [u8; 32], u8) {
        let version = bytes[0];
        assert(version == 1, "VM version incompatible");
        
        let (_, signatures_len, signatures, body_bytes, body_length) = parse_vaa_unconstrained(bytes, actual_length);

        assert(signatures_len >= 1, "Need at least 1 signature");
        assert(signatures_len <= 13, "Too many signatures");

        // Compute the VAA hash
        let hash = compute_vaa_hash_unconstrained(body_bytes, body_length);
        
        // Safety: get_hardcoded_guardians() doesn't need proving mode
        let guardians = get_hardcoded_guardians();

        // Prepare arrays for constrained verification
        let mut pub_keys_x = [[0; 32]; 13];
        let mut pub_keys_y = [[0; 32]; 13];
        let mut signature_bytes_array = [[0; 64]; 13];

        for i in 0..13 {
            if i < signatures_len {
                let sig = Signature::from_bytes(signatures[i as u32]);
                let guardian_idx = sig.guardian_index;

                assert(guardian_idx < 19, "guardian index out of bounds");

                // Safety: get_guardian_by_index_unconstrained() doesn't need proving mode
                let guardian = get_guardian_by_index_unconstrained(guardian_idx, guardians);

                // Get public key components as byte arrays
                let pub_key_x = guardian.get_pub_key_x();
                let pub_key_y = guardian.get_pub_key_y();

                pub_keys_x[i as u32] = pub_key_x;
                pub_keys_y[i as u32] = pub_key_y;

                // Prepare signature bytes
                let mut signature_bytes = [0; 64];
                for j in 0..32 {
                    signature_bytes[j] = sig.r[j];
                    signature_bytes[32 + j] = sig.s[j];
                }
                signature_bytes_array[i as u32] = signature_bytes;
            }
        }

        (pub_keys_x, pub_keys_y, signature_bytes_array, hash, signatures_len)
    }

    #[private]
    fn verify_vaa(bytes: [u8; 2000], actual_length: u32) {

        // Safety: verify_vaa_unconstrained performs parsing and validation that doesn't need constraints
        let (pub_keys_x, pub_keys_y, signature_bytes_array, hash, signatures_len) = unsafe {
            verify_vaa_unconstrained(bytes, actual_length)
        };

        // TODO svlachakis Change this for Testnet
        let required_signatures = 1;
        let mut verified_count = 0;

        for i in 0..13 {
            if i < signatures_len {
                let is_valid = std::ecdsa_secp256k1::verify_signature(
                    pub_keys_x[i as u32],
                    pub_keys_y[i as u32],
                    signature_bytes_array[i as u32],
                    hash
                );

                if is_valid {
                    verified_count += 1;
                }
            }
        }

        assert(verified_count >= required_signatures, "Insufficient valid signatures");
    }

}