{
  "contract_name": "wormchain-accounting",
  "contract_version": "0.1.0",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "type": "object",
    "required": [
      "guardian_set_index",
      "instantiate",
      "signatures"
    ],
    "properties": {
      "guardian_set_index": {
        "type": "integer",
        "format": "uint32",
        "minimum": 0.0
      },
      "instantiate": {
        "$ref": "#/definitions/Binary"
      },
      "signatures": {
        "type": "array",
        "items": {
          "$ref": "#/definitions/Signature"
        }
      }
    },
    "additionalProperties": false,
    "definitions": {
      "Binary": {
        "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>",
        "type": "string"
      },
      "Signature": {
        "type": "object",
        "required": [
          "index",
          "signature"
        ],
        "properties": {
          "index": {
            "description": "The index of the guardian in the guardian set.",
            "type": "integer",
            "format": "uint16",
            "minimum": 0.0
          },
          "signature": {
            "description": "The signature, which should be exactly 65 bytes with the following layout:\n\n```markdown 0  .. 64: Signature   (ECDSA) 64 .. 65: Recovery ID (ECDSA) ```",
            "allOf": [
              {
                "$ref": "#/definitions/Binary"
              }
            ]
          }
        },
        "additionalProperties": false
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "submit_observations"
        ],
        "properties": {
          "submit_observations": {
            "type": "object",
            "required": [
              "guardian_set_index",
              "observations",
              "signature"
            ],
            "properties": {
              "guardian_set_index": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              "observations": {
                "$ref": "#/definitions/Binary"
              },
              "signature": {
                "$ref": "#/definitions/Signature"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "modify_balance"
        ],
        "properties": {
          "modify_balance": {
            "type": "object",
            "required": [
              "guardian_set_index",
              "modification",
              "signatures"
            ],
            "properties": {
              "guardian_set_index": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              "modification": {
                "$ref": "#/definitions/Binary"
              },
              "signatures": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/Signature"
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "upgrade_contract"
        ],
        "properties": {
          "upgrade_contract": {
            "type": "object",
            "required": [
              "guardian_set_index",
              "signatures",
              "upgrade"
            ],
            "properties": {
              "guardian_set_index": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              "signatures": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/Signature"
                }
              },
              "upgrade": {
                "$ref": "#/definitions/Binary"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Binary": {
        "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>",
        "type": "string"
      },
      "Signature": {
        "type": "object",
        "required": [
          "index",
          "signature"
        ],
        "properties": {
          "index": {
            "description": "The index of the guardian in the guardian set.",
            "type": "integer",
            "format": "uint16",
            "minimum": 0.0
          },
          "signature": {
            "description": "The signature, which should be exactly 65 bytes with the following layout:\n\n```markdown 0  .. 64: Signature   (ECDSA) 64 .. 65: Recovery ID (ECDSA) ```",
            "allOf": [
              {
                "$ref": "#/definitions/Binary"
              }
            ]
          }
        },
        "additionalProperties": false
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "balance"
        ],
        "properties": {
          "balance": {
            "$ref": "#/definitions/Key"
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "all_accounts"
        ],
        "properties": {
          "all_accounts": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/Key"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "transfer"
        ],
        "properties": {
          "transfer": {
            "$ref": "#/definitions/Key"
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "all_transfers"
        ],
        "properties": {
          "all_transfers": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/Key"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "pending_transfer"
        ],
        "properties": {
          "pending_transfer": {
            "$ref": "#/definitions/Key"
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "all_pending_transfers"
        ],
        "properties": {
          "all_pending_transfers": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/Key"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "modification"
        ],
        "properties": {
          "modification": {
            "type": "object",
            "required": [
              "sequence"
            ],
            "properties": {
              "sequence": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "all_modifications"
        ],
        "properties": {
          "all_modifications": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Key": {
        "type": "object",
        "required": [
          "chain_id",
          "token_address",
          "token_chain"
        ],
        "properties": {
          "chain_id": {
            "type": "integer",
            "format": "uint16",
            "minimum": 0.0
          },
          "token_address": {
            "$ref": "#/definitions/TokenAddress"
          },
          "token_chain": {
            "type": "integer",
            "format": "uint16",
            "minimum": 0.0
          }
        },
        "additionalProperties": false
      },
      "TokenAddress": {
        "type": "string"
      }
    }
  },
  "migrate": null,
  "sudo": null,
  "responses": {
    "all_accounts": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "AllAccountsResponse",
      "type": "object",
      "required": [
        "accounts"
      ],
      "properties": {
        "accounts": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Account"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Account": {
          "type": "object",
          "required": [
            "balance",
            "key"
          ],
          "properties": {
            "balance": {
              "$ref": "#/definitions/Balance"
            },
            "key": {
              "$ref": "#/definitions/Key"
            }
          },
          "additionalProperties": false
        },
        "Balance": {
          "$ref": "#/definitions/Uint256"
        },
        "Key": {
          "type": "object",
          "required": [
            "chain_id",
            "token_address",
            "token_chain"
          ],
          "properties": {
            "chain_id": {
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "token_address": {
              "$ref": "#/definitions/TokenAddress"
            },
            "token_chain": {
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "TokenAddress": {
          "type": "string"
        },
        "Uint256": {
          "description": "An implementation of u256 that is using strings for JSON encoding/decoding, such that the full u256 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances out of primitive uint types or `new` to provide big endian bytes:\n\n``` # use cosmwasm_std::Uint256; let a = Uint256::from(258u128); let b = Uint256::new([ 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 1u8, 2u8, ]); assert_eq!(a, b); ```",
          "type": "string"
        }
      }
    },
    "all_modifications": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "AllModificationsResponse",
      "type": "object",
      "required": [
        "modifications"
      ],
      "properties": {
        "modifications": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Modification"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Kind": {
          "type": "string",
          "enum": [
            "add",
            "sub"
          ]
        },
        "Modification": {
          "type": "object",
          "required": [
            "amount",
            "chain_id",
            "kind",
            "reason",
            "sequence",
            "token_address",
            "token_chain"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint256"
            },
            "chain_id": {
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "kind": {
              "$ref": "#/definitions/Kind"
            },
            "reason": {
              "type": "string"
            },
            "sequence": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "token_address": {
              "$ref": "#/definitions/TokenAddress"
            },
            "token_chain": {
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "TokenAddress": {
          "type": "string"
        },
        "Uint256": {
          "description": "An implementation of u256 that is using strings for JSON encoding/decoding, such that the full u256 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances out of primitive uint types or `new` to provide big endian bytes:\n\n``` # use cosmwasm_std::Uint256; let a = Uint256::from(258u128); let b = Uint256::new([ 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 1u8, 2u8, ]); assert_eq!(a, b); ```",
          "type": "string"
        }
      }
    },
    "all_pending_transfers": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "AllPendingTransfersResponse",
      "type": "object",
      "required": [
        "pending"
      ],
      "properties": {
        "pending": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PendingTransfer"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Binary": {
          "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>",
          "type": "string"
        },
        "Data": {
          "type": "object",
          "required": [
            "guardian_set_index",
            "observation",
            "signatures"
          ],
          "properties": {
            "guardian_set_index": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "observation": {
              "$ref": "#/definitions/Observation"
            },
            "signatures": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/Signature"
              }
            }
          },
          "additionalProperties": false
        },
        "Key": {
          "type": "object",
          "required": [
            "emitter_address",
            "emitter_chain",
            "sequence"
          ],
          "properties": {
            "emitter_address": {
              "$ref": "#/definitions/TokenAddress"
            },
            "emitter_chain": {
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "sequence": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "Observation": {
          "type": "object",
          "required": [
            "key",
            "nonce",
            "payload",
            "tx_hash"
          ],
          "properties": {
            "key": {
              "$ref": "#/definitions/Key"
            },
            "nonce": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "payload": {
              "$ref": "#/definitions/Binary"
            },
            "tx_hash": {
              "$ref": "#/definitions/Binary"
            }
          },
          "additionalProperties": false
        },
        "PendingTransfer": {
          "type": "object",
          "required": [
            "data",
            "key"
          ],
          "properties": {
            "data": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/Data"
              }
            },
            "key": {
              "$ref": "#/definitions/Key"
            }
          },
          "additionalProperties": false
        },
        "Signature": {
          "type": "object",
          "required": [
            "index",
            "signature"
          ],
          "properties": {
            "index": {
              "description": "The index of the guardian in the guardian set.",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "signature": {
              "description": "The signature, which should be exactly 65 bytes with the following layout:\n\n```markdown 0  .. 64: Signature   (ECDSA) 64 .. 65: Recovery ID (ECDSA) ```",
              "allOf": [
                {
                  "$ref": "#/definitions/Binary"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "TokenAddress": {
          "type": "string"
        }
      }
    },
    "all_transfers": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "AllTransfersResponse",
      "type": "object",
      "required": [
        "transfers"
      ],
      "properties": {
        "transfers": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Transfer"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Data": {
          "type": "object",
          "required": [
            "amount",
            "recipient_chain",
            "token_address",
            "token_chain"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint256"
            },
            "recipient_chain": {
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "token_address": {
              "$ref": "#/definitions/TokenAddress"
            },
            "token_chain": {
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "Key": {
          "type": "object",
          "required": [
            "emitter_address",
            "emitter_chain",
            "sequence"
          ],
          "properties": {
            "emitter_address": {
              "$ref": "#/definitions/TokenAddress"
            },
            "emitter_chain": {
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "sequence": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "TokenAddress": {
          "type": "string"
        },
        "Transfer": {
          "type": "object",
          "required": [
            "data",
            "key"
          ],
          "properties": {
            "data": {
              "$ref": "#/definitions/Data"
            },
            "key": {
              "$ref": "#/definitions/Key"
            }
          },
          "additionalProperties": false
        },
        "Uint256": {
          "description": "An implementation of u256 that is using strings for JSON encoding/decoding, such that the full u256 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances out of primitive uint types or `new` to provide big endian bytes:\n\n``` # use cosmwasm_std::Uint256; let a = Uint256::from(258u128); let b = Uint256::new([ 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 1u8, 2u8, ]); assert_eq!(a, b); ```",
          "type": "string"
        }
      }
    },
    "balance": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Balance",
      "allOf": [
        {
          "$ref": "#/definitions/Uint256"
        }
      ],
      "definitions": {
        "Uint256": {
          "description": "An implementation of u256 that is using strings for JSON encoding/decoding, such that the full u256 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances out of primitive uint types or `new` to provide big endian bytes:\n\n``` # use cosmwasm_std::Uint256; let a = Uint256::from(258u128); let b = Uint256::new([ 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 1u8, 2u8, ]); assert_eq!(a, b); ```",
          "type": "string"
        }
      }
    },
    "modification": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Modification",
      "type": "object",
      "required": [
        "amount",
        "chain_id",
        "kind",
        "reason",
        "sequence",
        "token_address",
        "token_chain"
      ],
      "properties": {
        "amount": {
          "$ref": "#/definitions/Uint256"
        },
        "chain_id": {
          "type": "integer",
          "format": "uint16",
          "minimum": 0.0
        },
        "kind": {
          "$ref": "#/definitions/Kind"
        },
        "reason": {
          "type": "string"
        },
        "sequence": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "token_address": {
          "$ref": "#/definitions/TokenAddress"
        },
        "token_chain": {
          "type": "integer",
          "format": "uint16",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Kind": {
          "type": "string",
          "enum": [
            "add",
            "sub"
          ]
        },
        "TokenAddress": {
          "type": "string"
        },
        "Uint256": {
          "description": "An implementation of u256 that is using strings for JSON encoding/decoding, such that the full u256 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances out of primitive uint types or `new` to provide big endian bytes:\n\n``` # use cosmwasm_std::Uint256; let a = Uint256::from(258u128); let b = Uint256::new([ 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 1u8, 2u8, ]); assert_eq!(a, b); ```",
          "type": "string"
        }
      }
    },
    "pending_transfer": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Data",
      "type": "object",
      "required": [
        "guardian_set_index",
        "observation",
        "signatures"
      ],
      "properties": {
        "guardian_set_index": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "observation": {
          "$ref": "#/definitions/Observation"
        },
        "signatures": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Signature"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Binary": {
          "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>",
          "type": "string"
        },
        "Key": {
          "type": "object",
          "required": [
            "emitter_address",
            "emitter_chain",
            "sequence"
          ],
          "properties": {
            "emitter_address": {
              "$ref": "#/definitions/TokenAddress"
            },
            "emitter_chain": {
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "sequence": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "Observation": {
          "type": "object",
          "required": [
            "key",
            "nonce",
            "payload",
            "tx_hash"
          ],
          "properties": {
            "key": {
              "$ref": "#/definitions/Key"
            },
            "nonce": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "payload": {
              "$ref": "#/definitions/Binary"
            },
            "tx_hash": {
              "$ref": "#/definitions/Binary"
            }
          },
          "additionalProperties": false
        },
        "Signature": {
          "type": "object",
          "required": [
            "index",
            "signature"
          ],
          "properties": {
            "index": {
              "description": "The index of the guardian in the guardian set.",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "signature": {
              "description": "The signature, which should be exactly 65 bytes with the following layout:\n\n```markdown 0  .. 64: Signature   (ECDSA) 64 .. 65: Recovery ID (ECDSA) ```",
              "allOf": [
                {
                  "$ref": "#/definitions/Binary"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "TokenAddress": {
          "type": "string"
        }
      }
    },
    "transfer": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Data",
      "type": "object",
      "required": [
        "amount",
        "recipient_chain",
        "token_address",
        "token_chain"
      ],
      "properties": {
        "amount": {
          "$ref": "#/definitions/Uint256"
        },
        "recipient_chain": {
          "type": "integer",
          "format": "uint16",
          "minimum": 0.0
        },
        "token_address": {
          "$ref": "#/definitions/TokenAddress"
        },
        "token_chain": {
          "type": "integer",
          "format": "uint16",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "TokenAddress": {
          "type": "string"
        },
        "Uint256": {
          "description": "An implementation of u256 that is using strings for JSON encoding/decoding, such that the full u256 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances out of primitive uint types or `new` to provide big endian bytes:\n\n``` # use cosmwasm_std::Uint256; let a = Uint256::from(258u128); let b = Uint256::new([ 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 1u8, 2u8, ]); assert_eq!(a, b); ```",
          "type": "string"
        }
      }
    }
  }
}
