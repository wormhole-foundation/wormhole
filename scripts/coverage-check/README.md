# Go Coverage Check Tool

A minimal Go tool to enforce incremental test coverage improvements without blocking development.

## Rules

1. **No regression**: Packages in the baseline must maintain their coverage (within 0.1% tolerance)
2. **New packages need tests**: Any new package not in the baseline must have at least 10% coverage
3. **Improvements must be committed**: Coverage gains trigger a required baseline update

### What's Excluded from New Package Checks

- `cmd/`, `hack/`, `tools/`, `proto/`, `mock/` — infrastructure/generated code
- `*abi` — generated ABI bindings
- Root `node` package

These can still appear in the baseline if you want to track them.

## Usage

All coverage targets use the `coverage-*` prefix. Tab-complete `make coverage` to discover them:

```bash
make coverage             # Run tests + check against baseline (main entry point)
make coverage-init        # Create baseline from scratch (first-time setup)
make coverage-update      # Update baseline after improvements
make coverage-test        # Just run tests with coverage, no baseline check

VERBOSE=1 make coverage   # Detailed per-package breakdown
```

CI runs `make coverage` — the same command you run locally. Test flags (`-race`, `-cover`, `-timeout`) are defined once in the Makefile.

### CLI Flags (if running the binary directly)

```bash
./coverage-check           # Quiet mode (only shows failures and improvements)
./coverage-check -v        # Verbose mode (shows all checks)
./coverage-check -u        # Update baseline with current coverage
./coverage-check -init     # Create baseline from scratch (first-time setup)
```

The tool expects `coverage.txt` at repo root, generated by `make coverage-test`.

## Scenarios

| Situation | Result | Fix |
|-----------|--------|-----|
| You add tests, coverage improves | Exit 1 — "Coverage improved!" | `make coverage-update` to lock in gains |
| Coverage drops accidentally | Exit 1 — regression detected | Add tests to restore coverage |
| Coverage drops intentionally (dead code removal) | Exit 1 — regression detected | `make coverage-update` + commit with explanation |
| New package with <10% coverage | Exit 1 — below minimum | Add basic tests to reach 10% |
| New package with ≥10% coverage | Exit 1 — new package detected | `make coverage-update` to add to baseline |
| New `cmd/` or `hack/` code, no tests | Pass — excluded from checks | Nothing needed |

## Baseline File

The baseline (`.coverage-baseline` at repo root) maps packages to minimum coverage:

```
# Format: <package> <coverage-percentage>
github.com/certusone/wormhole/node/pkg/db 73.8
github.com/certusone/wormhole/node/pkg/query 69.9
```

**To update**: `make coverage-update` (preserves comments and structure).

**To manually edit**: Change the number, run `make coverage` to verify, commit with explanation.

**To create from scratch**: `make coverage-init` (one-time setup).

## Configuration

Edit constants in `scripts/coverage-check/main.go`:

```go
const (
    baselineFile       = ".coverage-baseline"  // Baseline file location (repo root)
    coverageOutputFile = "coverage.txt"        // Where to read test coverage from
    minNewPkgCoverage  = 10.0                  // Minimum for new packages
    coverageTolerance  = 0.1                   // Floating point tolerance
)
```

To add exclusions for generated code, add patterns to the `init()` function's pattern list.

## Troubleshooting

**"No coverage data found"**: Package was renamed or deleted. Update the baseline to match.

**"Minimum required: 10.0%" for generated code**: Add an exclusion pattern in `init()`.

**Passes locally, fails in CI (or vice versa)**: Both use `make coverage`. Run from repo root. If they still diverge, check Go version matches (`1.23.3`).

## FAQ

**Q: Why 10% minimum for new packages?**
Low enough to not block development, high enough to ensure basic tests exist.

**Q: Ship urgently without tests?**
Add the package to the baseline with 0% coverage. File a follow-up issue.

**Q: Why per-package baselines instead of total coverage?**
Total coverage drops as you add new code, which blocks development. Per-package is more granular and fair.

## Development

```
scripts/coverage-check/
├── main.go      # All logic (~600 lines)
├── go.mod       # Module declaration (stdlib only)
└── README.md    # This file
```

Key functions: `parseCoverageOutput()`, `loadBaseline()`, `checkBaseline()`, `checkNewPackages()`, `shouldExclude()`, `writeInitialBaseline()`, `writeUpdatedBaseline()`.
